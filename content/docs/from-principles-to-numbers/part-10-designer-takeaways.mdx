---
title: part-10-designer-takeaways
---
# Part 10: Designer Takeaways

You've read 80+ pages. Here's what matters most.

***

## The Core Process (One Page Summary)

### Step 1: Assess Design Context

**What's feasible for you?**

* Platform, player count, time budget, session structure
* Technical capability (computer? human GM? neither?)
* Resources available (designer time, playtesting access)

**Eliminates:** Infeasible paradigms before you consider aesthetics

### Step 2: Identify Aesthetic Goals

**What experience are you creating?**

* Primary aesthetic (Challenge? Narrative? Fellowship? Discovery?)
* Secondary aesthetics (supporting goals)
* Use MDA framework + expansions (Mastery, Tension, Progression, Collection)

**Determines:** Which paradigm will serve your goals

### Step 3: Choose Paradigm

**How will balance work?**

* **Framework:** Explicit negotiation, transparent stakes (Narrative, Discovery)
* **Consistency:** Fixed patterns, learnable (Challenge, Mastery)
* **Adaptive:** Dynamic adjustment, responsive (Fellowship, Discovery)
* **Hybrid:** Different paradigms for different subsystems

**Check:** Aesthetic-paradigm compatibility matrix (Part 2)

### Step 4: Identify Measurable Priorities

**What do you need to optimize?**

* From aesthetic goals → priority measurables
* From paradigm choice → required measurables
* Use catalog (Part 5) to understand each measurable

**Example:** Challenge + Consistency = optimize Pattern Consistency (HIGH), Consequence Severity (HIGH), Mastery Curve, Time-to-Kill Consistency

### Step 5: Choose Resolution Mechanic

**How do actions resolve?**

* Match requirements to mechanic:
  * Transparent + Fast + Partial success = 2d6
  * Granular + Tactical = d20
  * Player control + Drama = Dice pool
* Decision table (Part 6, Section 1)

**Critical:** Can't set HP without knowing damage scale

### Step 6: Set Parameters

**Derive actual numbers:**

**Framework paradigm:**

* Define 3 tiers per dimension (Risk, Effect)
* Set ranges for each tier (not exact values)
* Create GM guidance (principles not formulas)

**Consistency paradigm:**

* Define player baseline (HP, damage, to-hit)
* Calculate Time-to-Kill target (from measurables)
* Work backwards: Boss HP = Player DPR × Target Rounds
* Design 3-5 learnable patterns

**Adaptive paradigm:**

* Define baseline difficulty
* Set adaptation ranges (±30-50%)
* Create adaptation rules (help/challenge triggers)
* Set hard bounds (maximums and minimums)

### Step 7: Integrate Systems

**If using hybrid:**

* Create shared mechanical language (resource pools, unlocks)
* Test that subsystems connect
* Validate integration impact (does investigation matter in boss fight?)

### Step 8: Playtest Systematically

**Validate through play:**

* Phase 1: Mechanical validation (numbers work?)
* Phase 2: Experience validation (creates intended aesthetic?)
* Phase 3: Edge case testing (what breaks?)
* Phase 4: Polish testing (feels good?)
* Track quantitative data (hit rates, durations)
* Observe qualitative experience (engagement, frustration)

### Step 9: Iterate

**Adjust based on data:**

* First iteration: ±20%
* Second iteration: ±10%
* Final tuning: ±5%
* One change at a time
* Retest after each adjustment

### Step 10: Ship When Done

**You're done when:**

* Metrics within ±15% of targets (3+ sessions)
* Players report intended aesthetic experience
* No game-breaking exploits
* Diminishing returns on iteration

***

## The Most Important Insights

### 1. Balance Is Constraint Satisfaction

**Not:** Finding THE perfect number
**But:** Finding numbers that satisfy multiple constraints simultaneously

**Your constraints:**

* Design context (what's feasible)
* Aesthetic goals (what experience you want)
* Paradigm requirements (how balance works)
* Measurable targets (what you're optimizing for)

**The framework helps you identify and satisfy constraints systematically.**

### 2. Paradigm Must Match Aesthetic

**Most critical decision:** Choosing the right paradigm for your aesthetic

**Wrong paradigm = unfixable by tuning numbers**

* Challenge aesthetic + Adaptive paradigm (unbounded) = players can't master
* Discovery aesthetic + Consistency paradigm = boring after first playthrough
* Narrative aesthetic + No stakes = hollow choices

**Use compatibility matrix. If mismatch, rebuild.**

### 3. Framework Doesn't Replace Judgment

**What framework does:**

* Makes reasoning explicit
* Identifies what to measure
* Provides calculation methods
* Creates shared vocabulary

**What framework doesn't do:**

* Generate creative content (you design boss patterns)
* Eliminate playtesting (iteration still required)
* Produce unique solution (multiple valid designs exist)
* Remove all uncertainty (subjective feel remains)

**Framework makes you systematic, not formulaic.**

### 4. Measurables Cluster by Paradigm

**Pattern recognition:**

* Framework games consistently optimize: Risk Visibility, Agency Scope, Choice Reversibility
* Consistency games consistently optimize: Pattern Consistency, Consequence Severity, Mastery Curve
* Adaptive games consistently optimize: Coordination Requirement, Comeback Possibility, Tension Gradient

**Don't fight paradigm requirements.** If you choose Consistency, you need high Pattern Consistency. Accept it.

### 5. Your First Numbers Will Be Wrong

**Expect 20-50% error on first pass.**

**This is okay:** You're in the right order of magnitude

**Framework value:** Systematic iteration, not perfect first try

* Framework gets you to 540 HP (not 54 or 5400)
* Playtesting refines to 520 HP
* Better than guessing and landing at 2000 HP

**Iteration is expected, not failure.**

### 6. Constraints Create Meaning

**Paradox:** More constraints = more meaningful choices

**Freedom requires structure:**

* No HP tracking = no stakes = choices don't matter
* Infinite resources = no scarcity = no decisions
* No failure state = no tension = no accomplishment

**AI Dungeon failed by removing constraints.** Even narrative-first games need mechanical foundations.

### 7. Integration Makes Hybrids Work

**Different paradigms can coexist if:**

* Clear boundaries (players know which applies when)
* Shared mechanical language (investigation → boss fight via resource pool)
* No conflict (paradigms don't contradict each other)

**Most successful games use hybrids.** Pure paradigms are rare.

**Village Mystery + Boss Fight example:**

* Investigation: Framework (handle unpredictable approaches)
* Boss Fight: Consistency (pattern learning)
* Integration: Preparation pool + tactical unlocks

### 8. Playtest Experience, Not Just Math

**Math necessary but not sufficient.**

**You can have:**

* Time-to-Kill exactly on target
* Hit rates perfect
* DPR correct

**And still:**

* Boring (no patterns)
* Frustrating (no feedback)
* Hollow (no stakes)

**Optimize emotional measurables too:** Consequence Severity, Pattern Interest, Achievement Satisfaction, Flow State

### 9. Complexity Budget Is Real

**Every system costs:**

* Design time (must balance)
* Player cognitive load (must track)
* Testing time (must validate)
* Interaction complexity (exponential growth)

**Resist feature creep.** Simplify before adding.

**Good game:** 3 well-balanced systems
**Bad game:** 12 half-balanced systems

### 10. Scale Changes Everything

**What works at 10 items breaks at 100 items.**

**Design for scale from start:**

* Set bounds (level caps, power caps)
* Modular systems (independent balance)
* Ratio-based scaling (relative not absolute)
* Leave headroom (don't max numbers at launch)

**Or:** Accept you'll rebuild later (level squish, system consolidation)

***

## Quick Decision Trees

### "Which Paradigm Should I Use?"

```
Start: What's your primary aesthetic?

→ Challenge or Mastery
  ├─ Players will retry content? → Consistency
  └─ Single attempt only? → Framework (negotiate stakes) or Bounded Adaptive (help options)

→ Narrative
  ├─ Open-ended problem solving? → Framework
  └─ Authored story beats? → Framework or Consistency (fixed dramatic moments)

→ Fellowship
  ├─ Wide skill range? → Adaptive
  └─ Similar skill level? → Framework or Consistency + coordination mechanics

→ Discovery
  ├─ Replayability valued? → Adaptive (variety across runs)
  └─ Single playthrough? → Framework (handle novelty) or Consistency (if patterns are discovery)

→ Multiple aesthetics?
  └─ Use hybrid (different paradigms for different subsystems)
```

### "What Do I Optimize For?"

```
Start: What's your paradigm + aesthetic?

Challenge + Consistency:
→ Optimize: Pattern Consistency (HIGH), Consequence Severity (HIGH), Mastery Curve

Narrative + Framework:
→ Optimize: Risk Visibility (HIGH), Agency Scope (TACTICAL+), Choice Reversibility (LOW)

Fellowship + Adaptive:
→ Optimize: Coordination Requirement (HIGH), Comeback Possibility (HIGH), Tension Gradient

Discovery + Adaptive:
→ Optimize: Surprise Frequency (FREQUENT), Discovery Rate (HIGH), Option Space Size

Other combinations:
→ Use measurables catalog (Part 5), combine relevant priorities
```

### "Where Do I Start?"

```
Start: What phase of design are you in?

Haven't set any numbers yet:
1. Read Part 1 (Constraint Framework)
2. Read Part 2 (Paradigms)
3. Read Part 3 (find your recipe)
4. Skip to Part 6 (set numbers using recipe)
5. Jump to Part 7 (playtest)

Already have numbers but they're wrong:
1. Read Part 5 (identify which measurables are off)
2. Read Part 7 (systematic iteration)
3. Adjust ±20%, retest
4. If still wrong, return to Part 2 (paradigm mismatch?)

Game is growing, balance breaking:
1. Read Part 8 (scaling)
2. Implement bounds or tier system
3. Return to Part 7 (revalidate)

Everything is broken, help:
1. Read Part 9 (identify your pitfall)
2. Return to Part 1 (rebuild from foundation)
3. You probably skipped the framework initially
```

***

## What This Chapter Provides

### For New Designers

* **Systematic process** (not guesswork)
* **Vocabulary** (explain your decisions)
* **Starting point** (recipes for common cases)
* **Iteration method** (improve systematically)

### For Experienced Designers

* **Framework for intuition** (formalize what you already know)
* **Communication tool** (shared language with team)
* **Edge case handling** (systematic approach to problems)
* **Validation method** (know when you're done)

### For Solo Designers

* **Complete process** (all steps covered)
* **Decision trees** (when stuck, consult framework)
* **Playtesting protocol** (systematic validation)
* **Quick reference** (this part)

### For Teams

* **Shared vocabulary** (everyone uses same terms)
* **Design documentation** (framework explains choices)
* **Handoff process** (framework persists across designers)
* **Iteration protocol** (team validates systematically)

***

## What This Chapter Doesn't Provide

**Be realistic about scope:**

### 1. Long-Term Live Balance

* Years of League of Legends/WoW-scale balancing
* Requires teams, not individuals
* Continuous telemetry and rapid iteration
* This chapter: Foundation for first 1-2 years

### 2. Massive Complexity

* D\&D 5e's 13 classes across 20 levels
* Hundreds of interacting abilities
* This chapter: Small to medium systems (2-10 interacting subsystems)

### 3. Competitive Esports Balance

* High-level optimization and counter-strategies
* Professional player councils and expert balance
* This chapter: Foundation, not advanced competitive tuning

### 4. Content Generation

* Boss attack patterns (you design these)
* Framework applications (you write examples)
* Synergies and combinations (you create these)
* This chapter: Structure, not creativity

### 5. Guaranteed Success

* Framework reduces errors, doesn't eliminate them
* Still need playtesting and iteration
* Still need good design sense
* This chapter: Systematic improvement, not perfection

**If you need these:** Hire specialists, build teams, use industry tools. But framework still provides foundation.

***

## Resources and Next Steps

### If You Want to Go Deeper

**On MDA framework:**

* Hunicke, LeBlanc, Zubek (2004) - Original MDA paper

**On specific paradigms:**

* Framework: Read Blades in the Dark (Position/Effect system)
* Consistency: Play Dark Souls (pattern learning)
* Adaptive: Read Left 4 Dead 2 AI Director postmortems

**On playtesting:**

* "The Art of Game Design" by Jesse Schell (playtesting chapter)
* "Rules of Play" by Salen & Zimmerman (iteration methods)

**On scaling:**

* GDC talks on live service balance (League, Overwatch, etc.)
* Engineering blogs from live games

### If You Want Help

**Community resources:**

* Game design forums (r/gamedesign, r/tabletopgamedesign)
* Discord communities (indie game dev, RPG design)
* Local playtesting groups

**Professional help:**

* Balance consultants (for larger projects)
* Playtesting services (for systematic validation)
* Data analysts (for live games with telemetry)

### What to Do Next

**Right now:**

1. Identify your current design stage (new? existing? broken?)
2. Use decision tree above to find starting point
3. Read relevant parts (don't need to read all 90 pages if focused)
4. Apply framework to your design
5. Playtest within 1 week (don't overthink)

**This week:**

* Set initial numbers using Part 6 process
* Schedule first playtest
* Prepare tracking sheet (Part 7)

**This month:**

* Complete Phase 1 playtesting (mechanical validation)
* Iterate on biggest gaps (±20% adjustments)
* Move to Phase 2 (experience validation)

**This quarter:**

* Complete all playtesting phases
* Converge on final numbers
* Ship or move to next milestone

***

## Final Thoughts

### Balance Is Not Magic

**It feels like magic when:**

* Game perfectly tuned
* Players report "just right" difficulty
* Systems elegant and coherent

**But it's actually:**

* Systematic constraint satisfaction
* Iterative refinement through playtesting
* Matching paradigm to aesthetic
* Optimizing measurables that matter

**This chapter gave you the system.** You provide the craft.

### Perfect Balance Doesn't Exist

**Chasing perfection wastes time.**

**Good enough looks like:**

* Metrics within ±15% of targets
* Players report positive experience
* No game-breaking issues
* Team would play again

**Ship it.** Iterate if needed.

**"Done and improving" beats "perfect on paper."**

### Framework Is Training Wheels

**As you gain experience:**

* Framework becomes intuition
* Faster at identifying paradigm fit
* Better at estimating parameters
* More efficient iteration

**But:**

* Framework remains useful for:
  * Communication (team alignment)
  * Documentation (explaining decisions)
  * Edge cases (when intuition fails)
  * Training others (onboarding)

**Use framework until you don't need it. Then keep it for when you do.**

### You Can Do This

**This chapter is long (90+ pages) because balance is detailed work.**

**But:**

* Framework is learnable
* Process is systematic
* Examples show the way
* Iteration corrects mistakes

**Start small:**

* One system
* One session
* One playtest
* One iteration

**Then build:**

* More systems
* More sessions
* More feedback
* More confidence

**You have everything you need.**

**Now go balance your game.**

***

## Chapter Summary (For Quick Reference)

| Part | Topic                | Key Takeaway                              | When to Read           |
| ---- | -------------------- | ----------------------------------------- | ---------------------- |
| 1    | Constraint Framework | Balance = satisfying multiple constraints | Before starting        |
| 2    | Paradigms            | Match paradigm to aesthetic               | Before setting numbers |
| 3    | Recipes              | Common aesthetic+paradigm combinations    | Quick-start guide      |
| 4    | Real Games           | What works/fails in practice              | For validation         |
| 5    | Measurables          | What to optimize based on paradigm        | Reference material     |
| 6    | Numbers              | How to derive actual parameters           | Implementation         |
| 7    | Playtesting          | Systematic validation process             | During iteration       |
| 8    | Scaling              | How balance breaks as systems grow        | For expansions         |
| 9    | Pitfalls             | Common mistakes and how to avoid          | Troubleshooting        |
| 10   | Takeaways            | Core insights and decision trees          | Quick reference        |

**Most-referenced parts:**

* Part 3 (Recipes) - Starting point for common cases
* Part 6 (Numbers) - Implementation process
* Part 7 (Playtesting) - Iteration method
* Part 10 (This part) - Quick reference

**Bookmark these.** Return as needed.

***

**Supplementary: See worked scenario test for complete Village Mystery + Boss Fight walkthrough applying every step of framework.**
