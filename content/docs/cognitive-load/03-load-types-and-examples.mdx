---
title: 03-load-types-and-examples
---
# Part 3: Load Types and Game Examples

## Introduction: Dissecting Cognitive Load

In Part 2, we established that cognitive load is a design tool that shapes player experience. But "cognitive load" is not monolithic—it's actually several distinct types of mental effort that games can demand.

**A game might be:**

* High in simultaneity load (real-time pressure)
* Low in calculation load (simple math)
* Medium in decision load (meaningful but not overwhelming choices)

Understanding these distinct load types allows designers to be precise about what mental effort their game demands—and whether that effort serves their experiential goals.

This chapter examines seven core load types:

1. **Simultaneity Load** - tracking multiple things at once
2. **Memory/Knowledge Load** - what must be remembered or known
3. **Decision Load** - evaluating options and making choices
4. **Tracking Load** - monitoring game state
5. **Calculation Load** - mathematical computation
6. **Pattern Recognition Load** - learning through experience
7. **Social/Communication Load** - interpersonal coordination

For each type, we'll explore:

* What this load type is
* When it serves experience (good)
* When it obstructs experience (bad)
* Game examples across the spectrum
* Design principles

***

## Load Type 1: Simultaneity Load

### Definition

**Simultaneity load** = the mental effort required to track and respond to multiple things happening at the same time.

**Key characteristic:** Real-time pressure. Can't defer one task to handle another—must split attention.

**Scales with:**

* Number of simultaneous demands
* Speed/time pressure
* Whether you can pause

***

### The Spectrum

**MINIMAL:** Turn-based, single focus

* Chess: One decision at a time, unlimited thinking
* Slay the Spire: Cards await your choice
* Civilization: World pauses while you think

**LOW:** Real-time but manageable

* Animal Crossing: Gentle real-time, no urgency
* Stardew Valley: Day cycle but forgiving
* Many MMOs (non-raid): Can stop to think

**MEDIUM:** Multiple demands, some urgency

* RTS games with pause (They Are Billions single-player)
* XCOM with timers: Multiple soldiers, turn limit
* Overcooked: Coordination pressure but predictable

**HIGH:** Constant attention splitting required

* StarCraft: Macro + micro + scouting + positioning simultaneously
* MOBAs (League, Dota): Last-hitting + map awareness + teamfights
* Dungeon Defenders: Building + combat + resource management

**EXTREME:** Impossible to handle everything

* Dwarf Fortress: Hundreds of dwarves, dozens of systems, cascading failures
* Factorio megabases: Supply chains across enormous maps
* Eve Online fleet battles: Massive coordination challenges

***

### When Simultaneity Load Works

**Success Case: StarCraft**

**Load profile:**

* Base management (workers, buildings, tech)
* Army control (positioning, micro, engagements)
* Map awareness (scouting, vision, threats)
* Resource optimization (spending efficiently)
* All happening simultaneously

**Why it works:**

* **Load creates skill expression:** Better players prioritize more effectively
* **"Always more to do" is the point:** Infinite skill ceiling
* **Elegant constraint:** One simple limit (attention) creates complex gameplay
* **Competitive depth:** Load management IS the competition
* **Learnable patterns:** Can develop efficient habits over time

**Design lessons:**

* Simultaneity load can BE the challenge
* "What do I focus on right now?" is interesting question
* Must reward good prioritization, not random success
* Need to feel like making meaningful choices, not drowning in chaos

***

**Success Case: Overcooked (Cooperative)**

**Load profile:**

* Multiple cooking stations
* Ingredient prep, cooking, plating, washing
* Coordination between players
* Time pressure + customer orders

**Why it works:**

* **Distributed load:** Multiple players share attention burden
* **Clear communication:** Yelling instructions is fun
* **Structured chaos:** Busy but not incomprehensible
* **Fellowship through coordination:** Working together under pressure bonds people
* **Failure is funny:** Kitchen disasters are comedy, not tragedy

**Design lessons:**

* Simultaneity load works differently in co-op (can distribute)
* Communication under pressure creates social engagement
* "Controlled chaos" can be fun if scope is limited
* Failure should be entertaining in high-simultaneity games

***

### When Simultaneity Load Fails

**Failure Case: Dwarf Fortress (For Most Players)**

**Load profile:**

* Hundreds of individual dwarves with needs
* Dozens of production chains
* Multiple z-levels (3D fortress)
* External threats (goblins, forgotten beasts)
* Cascading failures (one problem triggers six more)

**Why it fails:**

* **Overwhelming, not challenging:** Can't keep track of everything
* **Failure feels random:** Couldn't see disaster coming
* **Not conquerable:** Even experts get surprised by emergent chaos
* **Too much emergence:** System interactions are unpredictable

**But succeeds for niche:**

* Intentional extreme (complexity is the draw)
* "Losing is fun" philosophy (failure is content)
* Emergent stories ("how my fortress fell")

**Design lessons:**

* Extreme simultaneity creates narrow appeal
* Most players can't handle 50+ simultaneous concerns
* Unpredictable emergence feels random, not challenging
* Know your audience (niche by design ≠ bad design, just limited)

***

### Design Principles: Simultaneity Load

**1. Real-time dramatically increases load budget spent**

* Turn-based = can handle high complexity in other dimensions
* Real-time = must reduce complexity elsewhere

**2. Pause changes everything**

* With pause: Can handle high complexity (process when needed)
* Without pause: Complexity must be manageable in real-time
* Same game, different experience (They Are Billions example)

**3. Simultaneity works best when:**

* Prioritization is interesting (meaningful choices about attention)
* Patterns can be learned (develop efficient habits)
* Load is bounded (not infinite accumulation)
* Failure is informative (can see what you missed)

**4. Distribute in co-op:**

* Multiple players can share simultaneity load
* Communication becomes gameplay (coordination challenge)
* Team size affects manageable complexity (more players = more total attention)

**5. UI reduces simultaneity load:**

* Clear alerts (draw attention to critical events)
* Visual hierarchy (important things stand out)
* Automation (handle routine tasks without attention)
* Sound design (audio cues for off-screen events)

***

## Load Type 2: Memory/Knowledge Load

### Definition

**Memory/knowledge load** = the mental effort required to remember rules, facts, or previous events to play effectively.

**Key distinction:**

* **Active memory:** "What happened last turn?" (working memory)
* **Knowledge base:** "How does this mechanic work?" (long-term learning)

**Scales with:**

* Rules complexity
* State to remember
* Setting/lore depth
* Time between sessions (memory decay)

***

### The Spectrum

**MINIMAL:** No memorization required

* Candy Crush: Rules visible, no hidden state
* Tic-Tac-Toe: Entire game state is visible
* Many casual mobile games

**LOW:** Simple rules, visible state

* Chess: Rules are simple, board shows everything
* Checkers: Even simpler than chess
* Modern board games (Catan, Ticket to Ride)

**MEDIUM:** Some rules complexity or hidden information

* Poker: Need to remember betting patterns, hand values
* Among Us: Track who claimed what, who was where
* Many RPGs: Character abilities, basic setting knowledge

**HIGH:** Extensive rules or significant hidden state

* Magic: The Gathering: Thousands of cards, complex interactions
* Warhammer 40k: Codex rules, unit stats, special abilities
* Netrunner: Both deck knowledge + tracking opponent's possible cards

**EXTREME:** Encyclopedic knowledge required

* Advanced Squad Leader: 400+ page rulebook
* Campaign for North Africa: Infamous for complexity
* Some ultra-complex wargames

***

### When Memory/Knowledge Load Works

**Success Case: Magic: The Gathering (For Engaged Players)**

**Load profile:**

* **Card knowledge:** Thousands of cards exist
* **Rules interactions:** Complex stack mechanics
* **Meta knowledge:** What decks are popular, how to sideboard
* **Game state:** Track graveyards, exiled cards, triggers

**Why it works:**

* **Depth rewards study:** More knowledge = better play
* **Mastery satisfaction:** "I know this interaction!"
* **Collection investment:** Owning cards creates attachment
* **Community support:** Wikis, forums, shared knowledge base
* **Scalable engagement:** Can play casually or competitively

**Design lessons:**

* High knowledge load works when there's community support
* Must reward study (knowledge = advantage)
* Allow scalable engagement (casual players don't need everything)
* Complexity should create interesting interactions, not arbitrary rules

***

**Success Case: Chess (Low Knowledge, High Skill)**

**Load profile:**

* **Rules:** Simple, learned in 20 minutes
* **Openings:** Can memorize, but not required
* **Patterns:** Develop over time through play
* **Calculation:** In-game thinking, not memorization

**Why it works:**

* **Low barrier to entry:** Can play immediately after learning rules
* **Infinite depth:** Pattern recognition develops over years
* **No hidden information:** Board shows everything
* **Knowledge is optional:** Can play without studying openings

**Design lessons:**

* Simple rules + complex tactics = accessible but deep
* Perfect information reduces memory load
* Skill can emerge from play, not study
* Optional depth (can study or just play)

***

### When Memory/Knowledge Load Fails

**Failure Case: Warhammer 40k (For New Players)**

**Load profile:**

* **Core rules:** Dense rulebook
* **Army-specific rules:** Each codex adds layers
* **Unit stats:** Dozens of numbers per unit type
* **Special abilities:** Unique rules for hundreds of units
* **FAQs and errata:** Rules change, must stay current

**Why it fails (for many):**

* **Barrier to entry:** Can't play casually without extensive study
* **Constant lookups:** Rules interrupt gameplay
* **Knowledge asymmetry:** Veteran vs. newbie isn't fun for either
* **Homework required:** Can't just show up and play

**But succeeds for committed players:**

* Depth rewards investment
* Army specialization (learn one faction deeply)
* Community shares knowledge
* Miniatures/IP create attachment despite load

**Design lessons:**

* High memory load creates barrier to entry
* If load prevents playing, it's too high
* Can succeed with other draws (miniatures, IP, community)
* But load is obstacle, not feature

***

**Failure Case: Kingdom Hearts Series (Lore Load)**

**Load profile:**

* **Story across 10+ games**
* **Complex mythology:** Keyblades, hearts, darkness, etc.
* **Convoluted plot:** Time travel, clones, memory manipulation
* **Required knowledge:** Can't understand sequel without playing all previous

**Why it fails:**

* **Load in wrong place:** Action game requiring narrative homework
* **Barrier to entry:** New players are lost
* **Obstructs gameplay:** Confusion breaks immersion
* **Not optional:** Can't just enjoy combat without story confusion

**Design lessons:**

* Don't require extensive knowledge in orthogonal dimension
* Action games should have low narrative complexity
* Narrative games should have low mechanical complexity
* Make complexity optional (can ignore lore and still play)

***

### Design Principles: Memory/Knowledge Load

**1. Distinguish required vs. optional knowledge:**

* **Required:** Must know to play at all (core rules)
* **Optional:** Enhances play but not necessary (advanced tactics)
* Keep required knowledge minimal
* Allow optional depth for engaged players

**2. Externalize memory when possible:**

* Reference sheets, cards, tooltips
* Make hidden information visible (UI)
* Don't require memorizing what could be displayed
* Especially critical for long gaps between sessions

**3. Knowledge load acceptable when:**

* Rewards study with advantage (mastery feels earned)
* Community shares knowledge (wikis, guides)
* Can play casually without full knowledge
* Complexity creates interesting decisions, not arbitrary rules

**4. Knowledge load fails when:**

* Prevents playing without extensive prep (barrier)
* Constant lookups interrupt flow
* Knowledge is arbitrary (not understandable patterns)
* Required in dimension orthogonal to core gameplay

**5. Long campaigns need low memory load:**

* If weeks/months between sessions, players WILL forget
* System must handle memory (not rely on players)
* Recap/summary systems essential
* Visible state better than hidden

***

## Load Type 3: Decision Load

### Definition

**Decision load** = the mental effort required to evaluate options and make choices.

**Scales with:**

* Number of options
* Depth of decision tree (consequences and counter-consequences)
* Information availability (perfect vs. hidden)
* Time to decide (turn-based vs. real-time)

**Key insight:** More options ≠ better. Can create analysis paralysis.

***

### The Spectrum

**MINIMAL:** No meaningful choices

* Many idle games: Obvious optimal path
* Walking simulators: Movement, not decisions
* Kinetic novels: Pure story, no choices

**LOW:** Few options, clear best choice

* Tic-Tac-Toe: Solvable game
* Many casual mobile games: Obvious next action
* Tutorial sequences: Guided, not open

**MEDIUM:** Meaningful choices, manageable options

* Most board games: 3-5 good options per turn
* Fate RPGs: Clear options, fictional positioning
* Many modern video games: Guided but not railroaded

**HIGH:** Complex decision space, many viable options

* Chess: Dozens of legal moves, deep calculation
* Civilization: Tech trees, diplomacy, warfare, economy
* Slay the Spire: Card synergies, route planning, relic interactions

**EXTREME:** Overwhelming option space

* Go: 361 possible first moves, incalculable depth
* Dwarf Fortress: Limitless building possibilities
* Grand strategy games: Everything is possible, nothing is clear

***

### When Decision Load Works

**Success Case: Chess**

**Load profile:**

* **Many legal moves:** Dozens per position
* **Deep consequences:** Must calculate 5-10 moves ahead
* **Perfect information:** Can see everything, still hard
* **Turn-based:** Time to think

**Why it works:**

* **Depth is the point:** Calculation challenge is the game
* **Learnable patterns:** Experience compresses complexity
* **Clear consequences:** Can understand why moves matter
* **Scalable skill:** Beginners see 2 moves, masters see 20

**Design lessons:**

* High decision load works when it's the challenge
* Turn-based allows high complexity
* Patterns emerge over time (chunking reduces perceived load)
* Perfect information + complex consequences = interesting

***

**Success Case: Slay the Spire**

**Load profile:**

* **Card choices:** Build deck over run
* **Path choices:** Which route, which events
* **Combat decisions:** Which cards to play, in what order
* **Relic synergies:** Hundreds of possible combinations

**Why it works:**

* **Manageable per decision:** 3-5 cards per hand, clear effects
* **Depth from accumulation:** Simple choices create complex builds
* **Learning curve:** Each run teaches interactions
* **Failure is cheap:** Quick restart, try different approach
* **Scalable difficulty:** Ascension levels add challenge

**Design lessons:**

* High total complexity from simple individual decisions
* Make each decision manageable, complexity emergent
* Failure should be learning opportunity
* Roguelike structure supports experimentation

***

### When Decision Load Fails

**Failure Case: Analysis Paralysis**

**Problem:** Too many options → can't decide → frustration

**Examples:**

* Civilization late game: 50+ cities, hundreds of units
* Open-world games without guidance: "What should I do?"
* RPGs with huge skill trees and unclear choices

**Why it fails:**

* **Overwhelming, not challenging:** Can't evaluate all options
* **Unclear consequences:** Don't know which matters
* **Optimization anxiety:** Fear of making wrong choice
* **Breaks flow:** Spend more time deciding than playing

**Design lessons:**

* More options isn't always better
* Must provide framework for evaluation (what matters?)
* Clear consequences (can understand trade-offs)
* Guide without railroading (highlight good paths)

***

**Failure Case: Trivial Choices**

**Problem:** Only one good option → "why am I choosing?"

**Examples:**

* Tic-Tac-Toe: Solved game, optimal play obvious
* Many RPG illusions of choice: All paths lead to same place
* Idle games: Obvious next upgrade

**Why it fails:**

* **No real decision:** Just finding the answer
* **No skill expression:** Everyone does same thing
* **Boring:** Why have choice if there's no choice?

**Design lessons:**

* If there's only one good answer, don't present it as choice
* Multiple viable paths needed for decisions to matter
* "Illusion of choice" is usually unsatisfying
* Either make choices meaningful or streamline

***

### Design Principles: Decision Load

**1. The sweet spot varies by aesthetic:**

* **Challenge:** High decision load acceptable (it's the point)
* **Fellowship:** Low decision load (brainspace for socializing)
* **Narrative:** Low-medium (don't break story flow)
* **Discovery:** Medium (enough to explore, not overwhelming)

**2. Manage option space:**

* 3-5 viable options = manageable sweet spot
* 10+ options = likely too many (unless can filter/categorize)
* 1 option = not a decision
* Infinite options = paralysis

**3. Make consequences understandable:**

* Players should grasp trade-offs
* Hidden consequences = feels arbitrary
* Clear but complex = interesting
* Simple and clear = accessible

**4. Time affects acceptable complexity:**

* Turn-based = can handle high decision load
* Real-time = must reduce (no time to think)
* Timed decisions = adds pressure, reduce complexity

**5. Decision load should scale with mastery:**

* Beginners: Fewer options, clearer paths
* Experts: More options reveal themselves
* Scalable difficulty helps (easy mode = simpler decisions)

***

## Load Type 4: Tracking Load

### Definition

**Tracking load** = the mental effort required to monitor game state—remembering what resources you have, what's happened, what conditions are active.

**Different from memory load:** Tracking is about current game state; memory is about rules/lore.

**Scales with:**

* Number of entities to track
* Hidden vs. visible state
* Rate of change (how often state updates)

***

### The Spectrum

**MINIMAL:** All state visible, static

* Tic-Tac-Toe: Nine squares, that's it
* Chess: Pieces on board, nothing hidden
* Many puzzle games: What you see is everything

**LOW:** Simple state, mostly visible

* Catan: Resources in hand, board state visible
* Connect Four: Column state obvious
* Many simple board games

**MEDIUM:** Moderate state, some tracking needed

* Poker: Remember betting patterns, count pot
* Among Us: Track alibis, who was where
* Many RPGs: Party status, quest objectives

**HIGH:** Extensive state, active tracking required

* StarCraft: Multiple bases, units, upgrades, enemy state
* Warhammer: Unit stats, conditions, special rules active
* Complex board games: Multiple tracks, hidden hands

**EXTREME:** Overwhelming state to track

* Dwarf Fortress: Hundreds of dwarves, dozens of systems
* Eve Online: Market data, fleet compositions, political landscape
* Advanced Squad Leader: Unit facing, ammo, morale, terrain effects

***

### When Tracking Load Works

**Success Case: Among Us**

**Load profile:**

* **Spatial tracking:** Who was where, when
* **Social tracking:** Who claimed what, voting patterns
* **Task tracking:** Which tasks completed, who did them
* **Behavioral patterns:** Who acts suspicious

**Why it works:**

* **Distributed tracking:** No one player tracks everything
* **Discussion phase pools information:** Share what you saw
* **Memory serves gameplay:** Tracking alibi inconsistencies is the game
* **Social support:** Group helps reconstruct events
* **Acceptable errors:** Misremembering creates drama, not game-breaking

**Design lessons:**

* Tracking load can be distributed across players
* Memory serves gameplay when it creates social deduction
* Pooling information is engaging (not just bookkeeping)
* Acceptable to be imperfect (human memory fallibility is feature)

***

**Success Case: Slay the Spire (Offloaded Tracking)**

**Load profile:**

* **Deck contents:** Game shows discard pile, draw pile size
* **Relics:** Always visible with tooltips
* **Enemy intents:** Shown clearly
* **Hand size, energy:** Displayed prominently

**Why it works:**

* **UI handles tracking:** Don't need to remember
* **Relevant info surfaced:** See what matters when it matters
* **Mental energy goes to decisions:** Not bookkeeping
* **Can focus on strategy:** System handles state management

**Design lessons:**

* Offload tracking to UI whenever possible
* Display relevant information contextually
* Players should think about strategy, not remember state
* Digital games excel at state management

***

### When Tracking Load Fails

**Failure Case: Complex Board Games Without Aids**

**Problem:** Need to remember extensive state without tools

**Examples:**

* Hidden traitor games without good player aids
* Complex wargames with too many tokens/states
* RPGs with elaborate status effect systems

**Why it fails:**

* **Mental overhead:** Constantly checking "do I have X condition?"
* **Errors break game:** Forgetting status = unfair advantage/disadvantage
* **Slows play:** Checking and rechecking state
* **Not fun:** Bookkeeping isn't gameplay

**Design lessons:**

* If players need to track it, give them tools
* Player aids, reference sheets, tokens for conditions
* Consider: does this state need to exist?
* Automation helps (if digital)

***

### Design Principles: Tracking Load

**1. Offload whenever possible:**

* UI displays state (don't make players remember)
* Tokens/markers for conditions
* Reference sheets, player aids
* Automation (if digital)

**2. Visible vs. hidden state:**

* Perfect information = lower tracking load (can always check)
* Hidden information = higher load (must remember)
* Choose based on aesthetic goals

**3. Rate of change matters:**

* Static state = easy to track (check once, done)
* Constantly changing = high load (must update mental model)
* Design for appropriate update frequency

**4. Tracking load fails when:**

* State is essential but poorly supported (no tools)
* Bookkeeping overshadows gameplay
* Errors break game fairness
* Players spend more time checking than playing

**5. Distributed tracking in multiplayer:**

* Multiple players can share tracking burden
* But needs communication (synchronize understanding)
* Good for co-op, complex for competitive (information asymmetry)

***

## Load Type 5: Calculation Load

### Definition

**Calculation load** = the mental effort required to compute outcomes—arithmetic, probability, optimization.

**Scales with:**

* Complexity of math (addition vs. multiplication vs. probabilities)
* Frequency of calculation (every action vs. occasional)
* Transparency (can you see the numbers or guess?)

**Key insight:** Calculation can enhance (engaging puzzle) or obstruct (tedious bookkeeping).

***

### The Spectrum

**ZERO:** No math at all

* Many narrative games
* Pure strategy (Go, abstract games)
* Social deduction games

**MINIMAL:** Simple counting

* Uno: Count up points
* Many card games: Simple addition
* Roll-and-move: Count spaces

**LOW:** Basic arithmetic

* D\&D 5e: d20 + modifier, compare to target
* Many board games: Simple resource costs
* Catan: Count resources, check building costs

**MEDIUM:** Moderate calculation

* D\&D 3.5e: Multiple modifiers, situational bonuses
* Warhammer: Roll dice, compare stats, wound charts
* Many tactical games: Damage calculation, ranges

**HIGH:** Complex calculation or optimization

* Magic: The Gathering: Stack resolution, triggered abilities
* Netrunner: Both players calculating simultaneously
* Some euros: Victory point optimization

**EXTREME:** Extensive calculation required

* Some 18xx train games: Route optimization, stock calculations
* Dwarf Fortress: Production chain optimization
* EVE Online: Spreadsheet-level math for market, logistics

***

### When Calculation Load Works

**Success Case: Puzzle Games (Calculation IS Gameplay)**

**Examples:**

* Sudoku: Logic and number relationships
* SpaceChem: Optimization puzzles
* Factorio: Production chain math

**Why it works:**

* **Calculation is the challenge:** Solving math puzzle is engaging
* **Optional depth:** Can eyeball or optimize
* **Clear goals:** Know what you're optimizing for
* **Satisfying solutions:** Elegant math feels good

**Design lessons:**

* Calculation load works when math is the game
* Must be interesting calculation (not just tedious arithmetic)
* Clear optimization targets
* Tools available (calculators, spreadsheets) if complex

***

**Success Case: Simple Resolution (D\&D 5e)**

**Load profile:**

* Roll d20, add modifier (one number)
* Compare to target number
* That's it

**Why it works:**

* **Fast:** No time spent calculating
* **Transparent:** Players see the math
* **Dramatic:** Dice add uncertainty, simple math maintains tension
* **Accessible:** Anyone can add single-digit numbers

**Design lessons:**

* Simple calculation doesn't break flow
* Transparency matters (players should understand the math)
* Single operation (roll + add) is sweet spot for accessibility
* Complex tactics can emerge from simple resolution

***

### When Calculation Load Fails

**Failure Case: D\&D 3.5e (Modifier Stacking)**

**Load profile:**

* Base attack bonus
* \+ Strength modifier
* \+ Enhancement bonus
* \+ Size modifier
* \+ Situational modifiers (flanking, high ground, etc.)
* Some stack, some don't (type restrictions)

**Why it fails:**

* **Slows combat:** Every attack requires 5+ additions
* **Errors common:** Easy to forget or miscalculate modifiers
* **Not engaging:** Bookkeeping, not decision-making
* **Obstructs gameplay:** Math breaks dramatic flow

**Design lessons:**

* Multiple modifiers create tedium
* If calculation doesn't create decisions, simplify
* Advantage/disadvantage (5e) solves this (no calculation, still meaningful)
* Complexity should be in tactics, not arithmetic

***

**Failure Case: EVE Online (Spreadsheet Simulator)**

**Load profile:**

* Market analysis: Buy/sell orders, price histories
* Logistics: Jump ranges, fuel costs, cargo capacity
* Industry: Material requirements, production times
* Fitting: Module stats, power grid, CPU, resistances

**Why it "fails" (for action-seekers):**

* **Math isn't combat:** Came for space battles, got Excel
* **Load in wrong place:** Optimization required for "action" game
* **Barrier to entry:** Can't casual-play without doing homework
* **Time sink:** Spreadsheets outside game for in-game success

**But succeeds for specific audience:**

* Optimization enthusiasts love the math
* "Thinking man's MMO" appeal
* Economic gameplay is legitimate aesthetic

**Design lessons:**

* Know what experience you're creating
* If action game, minimize calculation
* If optimization game, embrace calculation (but market as such)
* Don't surprise players with load in unexpected dimension

***

### Design Principles: Calculation Load

**1. Calculation should serve decisions:**

* If math creates interesting choices, include it
* If math is just busywork, remove it
* **Test:** "Does this calculation change my decision?"

**2. Transparency matters:**

* Players should see the numbers (not guess)
* Hidden calculation feels arbitrary
* Exception: If mystery is the point (roguelikes discovering damage formulas)

**3. Frequency vs. complexity trade-off:**

* **Frequent calculation:** Must be simple (every combat attack)
* **Rare calculation:** Can be complex (end-game scoring)
* Don't combine frequent + complex (tedious)

**4. Tools matter:**

* Digital games: Automate (no calculation load on players)
* Physical games: Keep math simple or provide calculators/apps
* Complex calculation requires external tools (spreadsheets acceptable)

**5. Different aesthetics, different tolerance:**

* **Challenge/Mastery:** Calculation can be puzzle
* **Fellowship:** Keep math minimal (interferes with socializing)
* **Tension:** Math breaks dramatic flow (simple or automated)
* **Expression:** Optimization math can be satisfying (if that's the expression)

***

## Load Type 6: Pattern Recognition Load

### Definition

**Pattern recognition load** = the mental effort required to learn systems through experience—identifying what works, what doesn't, and why.

**Different from knowledge load:** Not memorizing facts, but developing intuition through play.

**Scales with:**

* Complexity of patterns
* Consistency (can patterns be learned?)
* Feedback clarity (do you know why things happened?)

***

### The Spectrum

**MINIMAL:** No patterns to learn

* Random games (pure luck)
* Trivial games (obvious patterns)
* Single-playthrough narratives

**LOW:** Simple patterns, quick learning

* Tic-Tac-Toe: Patterns obvious after few games
* Many casual games: Mechanics clear immediately
* Tutorial sequences: Explicit teaching

**MEDIUM:** Learnable patterns through play

* Dark Souls: Enemy attack patterns
* Slay the Spire: Card synergies
* Poker: Reading opponents, betting patterns

**HIGH:** Deep patterns, long learning curve

* Chess: Positional patterns develop over years
* Go: Shape recognition, territorial judgment
* StarCraft: Build orders, timing windows, map control

**EXTREME:** Incalculable complexity

* Go (endgame): Beyond human calculation
* Complex simulations: Emergent patterns from many systems
* "Solved by feel" not analysis

***

### When Pattern Recognition Load Works

**Success Case: Dark Souls**

**Load profile:**

* **Enemy patterns:** Learn attack tells, timings
* **Environmental patterns:** Trap locations, ambush points
* **Upgrade patterns:** Which stats matter, weapon scaling
* **World patterns:** Area layouts, shortcut locations

**Why it works:**

* **Dying teaches patterns:** Each death provides information
* **Consistent rules:** Same enemy always acts same way
* **Clear feedback:** Know what killed you, can learn
* **Mastery satisfaction:** Going from "impossible" to "easy" feels earned
* **Skill ceiling:** Always something new to learn (no-hit runs possible)

**Design lessons:**

* Pattern recognition can be primary skill expression
* Requires consistency (patterns must be learnable)
* Requires clear feedback (understand what happened)
* Death as teacher (failure should inform, not just punish)
* Progression through learning, not just stat increase

***

**Success Case: Chess (Pattern Recognition Over Calculation)**

**Load profile:**

* **Opening patterns:** Named openings, standard responses
* **Tactical patterns:** Forks, pins, skewers
* **Positional patterns:** Pawn structures, piece placement
* **Endgame patterns:** King and pawn positions, tablebase knowledge

**Why it works:**

* **Chunking reduces load:** Grandmasters see patterns, not individual pieces
* **Patterns compress experience:** 50,000 hours becomes intuition
* **Transferable learning:** Patterns learned in one game apply to others
* **Infinite depth:** Always deeper patterns to recognize
* **"Sense" develops:** Can "feel" good moves without full calculation

**Design lessons:**

* Expert play can rely on pattern recognition over calculation
* Chunking transforms high load into intuition
* Long-term investment creates deep mastery
* Patterns should be discoverable but not obvious
* Intuition emerges from consistent rules

***

### When Pattern Recognition Load Fails

**Failure Case: Random/Inconsistent Systems**

**Problem:** Can't learn patterns if no patterns exist

**Examples:**

* Pure randomness (no skill expression)
* Inconsistent rules (outcomes arbitrary)
* Too much emergent complexity (patterns are noise)

**Why it fails:**

* **No learning possible:** Practice doesn't improve performance
* **Frustrating:** Can't understand why things happen
* **No mastery:** Skill doesn't matter

**Design lessons:**

* Pattern recognition requires consistency
* Random outcomes should have learnable distributions
* If no pattern exists, can't be learned (obviously)

***

**Failure Case: Opaque Systems**

**Problem:** Patterns exist but invisible to players

**Examples:**

* Hidden formulas (can't learn what you can't see)
* Unclear feedback (don't know what caused outcome)
* Too many variables (signal lost in noise)

**Why it fails:**

* **Can't learn from experience:** No clear cause-effect
* **Feels arbitrary:** Outcomes seem random even if deterministic
* **Frustrating:** Know patterns exist but can't discover them

**Design lessons:**

* Feedback must be clear enough to learn
* If pattern is too hidden, might as well be random
* Either make patterns discoverable or don't require learning them

***

### Design Principles: Pattern Recognition Load

**1. Consistency is essential:**

* Same input → same output (at least probabilistically)
* If patterns are learnable, they must be consistent
* Exceptions should be rare and well-signaled

**2. Feedback enables learning:**

* Players must understand what happened and why
* Clear cause-effect relationships
* "What killed me?" must be answerable

**3. Appropriate depth for game length:**

* **One-shot games:** Patterns should be learnable in one session
* **Campaign games:** Can have deeper patterns revealing over time
* **Competitive games:** Infinite skill ceiling (always more to learn)

**4. Scaffolded learning:**

* Early patterns should be obvious (teach system)
* Later patterns can be subtle (reward expertise)
* Don't overwhelm with complexity at start

**5. Mastery should feel earned:**

* Going from struggling to succeeding = satisfying
* Pattern recognition mastery creates "flow"
* Experts should look effortless (internalized patterns)

***

## Load Type 7: Social/Communication Load

### Definition

**Social/communication load** = the mental effort required to coordinate, deceive, read, or negotiate with other players.

**Different from solo cognitive load:** Involves modeling other minds, not just system states.

**Scales with:**

* Number of players
* Cooperation vs. competition
* Information asymmetry
* Communication constraints

***

### The Spectrum

**ZERO:** Single-player

* No social load at all
* All load is system-focused

**LOW:** Minimal interaction

* Parallel play (everyone does own thing)
* Simple trading (Catan-style)
* Asynchronous turns

**MEDIUM:** Coordination or negotiation

* Pandemic: Coordinate strategy
* Diplomacy: Negotiation required
* Party games: Light social interaction

**HIGH:** Intensive coordination or deception

* Among Us: Social deduction, memory, deception
* Werewolf/Mafia: Reading tells, persuasion
* Bridge: Deep partnership coordination

**EXTREME:** Complex social dynamics

* Megagames: 50+ player coordination
* EVE Online: Alliance politics, espionage
* Political intrigue campaigns

***

### When Social/Communication Load Works

**Success Case: Among Us**

**Load profile:**

* **Memory:** Who was where, who claimed what
* **Deception:** (As Impostor) Create believable alibi
* **Detection:** (As Crewmate) Spot inconsistencies
* **Persuasion:** Convince group of your theory
* **Social reading:** Voice tone, behavior patterns

**Why it works:**

* **Distributed load:** Group collectively deduces
* **Asymmetric load:** Impostor has harder job (lying is work)
* **Communication is gameplay:** Discussion phase is the game
* **Social dynamics:** Reading friends creates engagement
* **Scalable:** Can play casually or seriously

**Design lessons:**

* Social load can BE the game (not just addition)
* Distributed cognition (no one tracks everything)
* Asymmetric load creates role variety
* Communication should be structured (discussion phases)
* Friend groups add meta-knowledge (makes it deeper)

***

**Success Case: Pandemic (Cooperative)**

**Load profile:**

* **Coordination:** Who goes where, in what order
* **Communication:** Share information, plan strategy
* **Distributed decisions:** Each player has different capabilities
* **Collective problem-solving:** Work together on puzzle

**Why it works:**

* **Load is shared:** Multiple brains solving together
* **Communication adds, not competes:** Talking IS solving
* **Asymmetric abilities:** Each player contributes differently
* **Victory shared:** Coordination creates fellowship
* **Accessible:** Low individual load, high collective capability

**Design lessons:**

* Cooperative games benefit from distributed load
* Communication should be encouraged (not punished)
* Asymmetric abilities create coordination opportunities
* Shared victory motivates coordination effort

***

### When Social/Communication Load Fails

**Failure Case: Analysis Paralysis in Co-op**

**Problem:** Too much coordination load = quarterbacking

**Examples:**

* Pandemic when one player dominates
* Any co-op where optimal play is calculable
* Group decisions with clear best answer

**Why it fails:**

* **One player does all thinking:** Others feel passive
* **Not fun for non-optimal players:** "Just do what I say"
* **Breaks fellowship:** Becomes lecture, not collaboration
* **Optimization overshadows experience:** Focus on winning, not playing

**Design lessons:**

* Limit information sharing (can't fully optimize)
* Hidden hands or personal information
* Time limits on discussion
* Asymmetric information prevents full coordination

***

**Failure Case: Communication Constraints Too Harsh**

**Problem:** Can't communicate effectively = frustration

**Examples:**

* Charades-style games when players can't convey ideas
* Asymmetric information games where critical info can't be shared
* Complex coordination without tools (no shared map)

**Why it fails:**

* **Frustration:** Know what to say but can't
* **Helplessness:** Can't prevent disaster
* **Unfun restrictions:** Artificial limitation feels bad
* **Failure feels unearned:** Lost due to constraint, not skill

**Design lessons:**

* Communication constraints must serve gameplay
* If constraint creates frustration, not challenge, remove it
* Tools matter (shared visual aids, etc.)
* Difficulty should be in coordination, not communication mechanics

***

### Design Principles: Social/Communication Load

**1. Social load competes with mechanical load:**

* High social load → need LOW mechanical load (brainspace for people)
* Fellowship games: Simple mechanics, complex social
* Strategy games: Complex mechanics, minimal social

**2. Distributed cognition:**

* Multiple players can share cognitive burden
* Total complexity can be higher in multiplayer
* But: requires communication bandwidth

**3. Asymmetric load creates variety:**

* Different roles have different load profiles
* Among Us: Impostor vs. Crewmate
* Cooperative: Different abilities, different responsibilities
* Variety prevents boredom

**4. Structure communication:**

* Discussion phases (Among Us, Werewolf)
* Turn order (prevents talking over)
* Information reveals (create discussion topics)

**5. Meta-knowledge matters:**

* Friend groups develop patterns
* "I know how Bob plays" creates depth
* Repeated play with same group adds layer
* Design for this (meta-knowledge as feature)

***

## Cross-Cutting Observations

### Observation 1: Load Types Interact

**Examples:**

* **Real-time (simultaneity) reduces available decision load**
  * StarCraft: Must make fast decisions (less calculation time)
  * Turn-based: Can make deeper decisions (more time to think)

* **High memory load reduces available decision load**
  * If tracking complex state, less bandwidth for decisions
  * Warhammer: Remembering rules competes with tactical thinking

* **Social load reduces available mechanical load**
  * Fellowship games need simple mechanics (brainspace for socializing)
  * Complex strategy games reduce social interaction

**Design principle:** Total cognitive budget is limited. High load in one dimension means must reduce in others.

***

### Observation 2: Load Types Have Different Aesthetic Mappings

**Challenge/Mastery aesthetics can handle:**

* High decision load (interesting choices)
* High pattern recognition load (learning challenge)
* Medium-high simultaneity load (prioritization challenge)

**Fellowship/Narrative aesthetics need:**

* Low calculation load (don't break flow)
* Low tracking load (brainspace for social/story)
* Low-medium decision load (choices without paralysis)

**Specific mappings:**

* **Sensation:** LOW everything (pure experience)
* **Fantasy:** LOW calculation, MEDIUM decision (immersion)
* **Narrative:** LOW mechanical, focus on story
* **Challenge:** HIGH decision, pattern, or simultaneity (the point)
* **Fellowship:** LOW mechanical, HIGH social
* **Discovery:** MEDIUM-HIGH (depends on what's discovered)
* **Expression:** MEDIUM tools + space
* **Submission:** LOW-MEDIUM repetitive

***

### Observation 3: Time Pressure Is Load Multiplier

**Turn-based:**

* Can handle high decision load
* Can handle high calculation load
* Can handle moderate tracking load
* Time to think = higher acceptable complexity

**Real-time:**

* Must reduce decision load (no time to calculate)
* Must reduce calculation load (no time for math)
* Must reduce tracking load (can't check everything)
* Pattern recognition becomes primary skill

**Design principle:** Real-time dramatically reduces complexity budget. Must simplify in all other dimensions.

***

### Observation 4: Digital vs. Physical Affects Load

**Digital advantages:**

* Automate calculation (no player math)
* Automate tracking (state management)
* Provide perfect information (UI displays)
* Enable complexity (system handles load)

**Physical advantages:**

* Tactile feedback (physical pieces)
* Social presence (face-to-face)
* No technical barriers (anyone can play)
* Simpler rules (can't rely on automation)

**Design implication:**

* Digital games can have higher tracking/calculation load
* Physical games must keep these loads low
* Choose platform based on load profile

***

## Summary: Load Type Considerations

When designing, ask for each load type:

**Simultaneity:**

* Is this real-time or turn-based?
* How many things happen at once?
* Can players pause/manage attention?

**Memory/Knowledge:**

* What must players remember?
* Can we externalize memory (UI, reference sheets)?
* Is knowledge barrier acceptable for audience?

**Decision:**

* How many options per decision point?
* How deep are consequences?
* Is analysis paralysis a risk?

**Tracking:**

* What state must players monitor?
* Can we offload to UI/system?
* Is hidden information necessary?

**Calculation:**

* How much math is required?
* Can we automate or simplify?
* Does calculation serve decisions?

**Pattern Recognition:**

* What must be learned through play?
* Are patterns consistent/discoverable?
* Is feedback clear?

**Social/Communication:**

* How much coordination required?
* Is load distributed or individual?
* Does social load compete with mechanical?

**For each type:** Does this load serve the experience, or obstruct it?

***

## Next Chapter

Part 4 explores how cognitive load changes over time through investment—how practice can reduce load, reveal deeper complexity, or create attachment through mastery. We'll examine learning curves, the mastery paradox, and design implications for progression systems.
