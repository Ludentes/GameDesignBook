---
title: 08-load-support-systems
---
# Part 8: Supporting and Removing Load

## Introduction

Cognitive load isn't inherently bad—but it must be **managed**. Even high-load games need tools to make complexity accessible. Even low-load games need thoughtful design to keep systems simple.

This chapter explores practical techniques for:

* **Supporting necessary load** (tools, UI, information design)
* **Removing unnecessary load** (simplification, automation, offloading)
* **Onboarding players** (tutorials, learning curves, gradual complexity)
* **Scaling across expertise** (novice → expert progression)

***

## Part A: Supporting Necessary Load

When cognitive load serves the experience (Challenge, Mastery, Discovery), we don't want to remove it—we want to make it **manageable** through good design.

### Technique 1: Externalization Tools

**Principle:** Move information from player memory to external reference.

**Why it helps:** Human working memory is limited (\~7 items). Offloading to external tools frees up brainspace for decisions.

***

**1A: Physical/Digital Reference Materials**

**Quick Reference Sheets**

* Condense essential rules to one page
* Always visible during play
* No flipping through rulebook mid-game

**Example: RPG reference sheets**

* Action types (move, attack, bonus action)
* Common rules (advantage/disadvantage, cover, conditions)
* NOT full rules (just frequent lookups)

**Design principle:** Include what players need DURING play, not during learning.

***

**Player Aids: Tracking Sheets, Journals, Checklists**

**Character Sheets (RPGs)**

* Externalize all mechanical info (stats, abilities, inventory)
* Players don't memorize—just read from sheet
* Good sheets organize info by when it's needed (combat abilities grouped together)

**Quest Logs / Mission Trackers**

* Externalize narrative state ("what am I doing and why?")
* Especially important for games with gaps between sessions
* LLM-maintained logs can be personalized and adaptive

**Resource Trackers**

* Physical tokens, dials, or digital counters
* Visible state (don't need to remember "do I have 7 or 8 gold?")
* Examples: Poker chips for currency, cubes for resources, health dials

**Design principle:** If players need to track it, give them a tool to track it visibly.

***

**1B: Visual Aids and Spatial Organization**

**Maps and Boards**

* Externalize spatial information
* Can see positions, relationships, territories at a glance
* Examples: Board game maps, tactical grids, relationship diagrams

**Color Coding**

* Reduces cognitive load for categorization
* "Red cards are attacks, blue are defenses" (instant recognition)
* Examples: Magic the Gathering colors, Pandemic disease cubes

**Icons and Symbols**

* Replace text with visual shorthand (faster to parse)
* Universal symbols reduce language load
* Examples: Heart = health, Skull = danger, Wrench = repair

**Physical Separation**

* "Discard pile goes here, draw pile here, active cards here"
* Spatial memory stronger than abstract memory
* Organized play space reduces "where did I put that?" load

**Design principle:** Leverage spatial and visual processing (stronger than verbal memory).

***

**1C: Digital Tools and Automation**

**Automated Calculation**

* Computer handles math (health tracking, damage calculation, resource totals)
* Players just make decisions (system shows results)
* Examples: Digital character sheets, automated combat resolution

**Searchable Databases**

* Can look up rules, cards, abilities without memorizing
* Indexed by keywords (faster than manual search)
* Examples: Digital card databases, ability wikis, rule search tools

**State Management Systems**

* Track game state invisibly (players don't manually update)
* Especially valuable for complex tracking (hidden information, timers, conditions)
* LLM-assisted: Can maintain narrative state, NPC memories, world changes

**Reminders and Prompts**

* System reminds players of important info at right time
* "Your ability recharges now" / "You have advantage on this roll"
* Reduces "did I remember to apply X?" load

**Design principle:** Automate bookkeeping, surface decisions. Players should spend cognitive effort on WHAT to do, not tracking WHAT IS.

***

### Technique 2: Information Design and UI

**Principle:** Present information clearly so it's easy to parse.

**Why it helps:** Even simple information can be hard to use if poorly presented. Good UI reduces cognitive load without reducing system complexity.

***

**2A: Information Hierarchy**

**Most Important Information Most Prominent**

* Size, color, position signal importance
* Players shouldn't hunt for critical info
* Example: Health bar large and central, minor stats small and periphery

**Progressive Disclosure**

* Show basic info by default, details on demand
* Don't overwhelm with everything at once
* Example: Tooltip on hover (brief description visible, full rules on click)

**Contextual Relevance**

* Show info when it's needed, hide when it's not
* "You're in combat" → show combat abilities prominently
* "You're exploring" → show navigation/interaction options

**Design principle:** Reduce visual noise. Only show what matters RIGHT NOW.

***

**2B: Chunking and Grouping**

**Chunk Related Information**

* Group info that's used together (all combat stats together, all social stats together)
* Reduces search time ("where's that number I need?")
* Example: Character sheet sections (Attributes, Skills, Equipment, Spells)

**Consistent Layout**

* Same info always in same place
* Builds spatial memory (don't need to search, just look at "the top-left corner")
* Example: All cards have name at top, cost at top-right, effect at bottom

**Visual Consistency**

* Same design language throughout
* Players learn patterns once, apply everywhere
* Example: All action buttons blue, all cancel buttons red

**Design principle:** Leverage pattern recognition. Once learned, layout should be effortless.

***

**2C: Feedback and Clarity**

**Immediate Feedback**

* Actions have clear results (no ambiguity about "did that work?")
* Visual/audio confirmation (damage numbers, hit sounds, color changes)
* Example: Character flashes when hit, resources sparkle when gained

**Clear State Communication**

* "Is my ability ready?" should be instantly answerable
* Visual indicators for status (cooldowns, buffs/debuffs, active effects)
* Example: Grayed-out = unavailable, glowing = ready, pulsing = active

**Error Prevention**

* Can't make invalid moves (system prevents illegal actions)
* Better than showing error after attempt (frustrating)
* Example: Can't click on invalid target, can't play card without resources

**Undo/Rewind (When Appropriate)**

* Allow fixing mistakes without penalty
* Reduces anxiety about irreversible choices
* Example: Can take back move in turn-based game before confirming

**Design principle:** Make game state transparent. Players shouldn't have to guess or calculate—they should SEE.

***

### Technique 3: Scaffolded Decision-Making

**Principle:** Help players make decisions without making decisions for them.

**Why it helps:** Decision load can be paralyzing. Scaffolding structures choices without removing agency.

***

**3A: Reduce Option Overload**

**Limit Choices (When Appropriate)**

* 3-5 good options better than 20 mediocre ones
* "Analysis paralysis" happens with too many similar options
* Example: Present 4 strong abilities, not 40 minor variations

**Default Recommendations**

* Suggest reasonable choice (players can override)
* "Auto-equip best weapon" option for those who don't want to optimize
* Don't force, just offer (respects player agency)

**Tiered Complexity**

* Basic options always available (simple, effective)
* Advanced options unlockable/optional (for those who want depth)
* Example: Fighter can just "attack" OR use special maneuvers if they want

**Design principle:** Make simple play viable. Complexity should be opt-IN, not mandatory.

***

**3B: Present Consequences Clearly**

**Show Expected Outcomes**

* "This attack has 70% chance to hit for 10 damage"
* Players make informed decisions (not blind guesses)
* Example: XCOM shows hit percentages, damage ranges

**Compare Options**

* Side-by-side comparison of choices
* "Option A does X, Option B does Y" (easier than remembering each separately)
* Example: Upgrade screens show old vs. new stats

**Forecast Impact**

* "If you do this, here's what happens next"
* Reduces "I didn't know that would happen!" frustration
* Example: Civ shows "if you settle here, you'll have these resources"

**Design principle:** Transparency enables good decisions. Hidden consequences feel unfair.

***

**3C: Structure Complex Decisions**

**Break Decisions Into Steps**

* One big decision → several small decisions
* Each step is manageable (overall is complex but not overwhelming)
* Example: Character creation wizard (race → class → abilities, not all at once)

**Decision Templates**

* Common patterns (can reuse mental models)
* "Every combat, you: Move → Attack → Use ability" (consistent structure)
* Reduces cognitive load through routine

**Undo/Iterate**

* Allow experimentation without commitment
* "Try this build, see if you like it, can change later"
* Example: Respec systems in RPGs

**Design principle:** Complex decisions are manageable when scaffolded into smaller steps.

***

## Part B: Removing Unnecessary Load

When cognitive load DOESN'T serve the experience, remove it ruthlessly.

### Technique 4: Simplification Without Dumbing Down

**Principle:** Reduce complexity without reducing depth.

**Why it matters:** Simple rules can create complex interactions. Complicated rules can create shallow games. Simplicity is a design virtue.

***

**4A: Elegant Core Mechanics**

**Unified Resolution Systems**

* One core mechanic that handles everything
* Not "roll d20 for attack, d6 for damage, d12 for saving throws"
* Example: Powered by the Apocalypse games (always 2d6 + stat)

**Consistent Keywords**

* Same term always means same thing
* Not "flying" in one rule and "airborne" in another (same concept, different words)
* Example: Magic the Gathering keywords (Trample, Lifelink—consistent across all cards)

**Minimal Exceptions**

* Special cases create memory load
* Better: Consistent rules with emergent complexity
* Example: Chess (simple rules, complex game) vs. Munchkin (lots of exceptions)

**Design principle:** Fewer rules, more depth. Emergent complexity from simple interactions.

***

**4B: Abstract Away Tedious Details**

**Aggregate Resources**

* "Supplies" instead of "23 rations, 15 torches, 8 ropes, 6 waterskins"
* Light/Medium/Heavy instead of exact counts
* Example: Blades in the Dark (Coin is abstract wealth, not exact gold pieces)

**Handwave Minor Bookkeeping**

* "You have standard adventuring gear" (don't track each item)
* "Your character can afford common expenses" (don't count every copper piece)
* Example: Modern D\&D (lifestyle costs, not itemized living expenses)

**Narrative Over Simulation**

* If it doesn't create decisions, abstract it
* "You travel for three days" not "Day 1: roll for weather, random encounter, rations..."
* Example: Montage scenes in narrative games

**Design principle:** Simulate only what matters. Everything else is narrative gloss.

***

**4C: Streamline Resolution**

**Reduce Calculation Steps**

* Fewer modifiers, simpler math
* Roll + stat vs. target (not roll + stat + circumstance + temporary - penalty...)
* Example: D\&D 5e advantage/disadvantage (roll twice, take higher/lower) vs. 3.5e (+2 for this, -1 for that...)

**Binary or Tiered Results**

* Success/Failure (or Success/Mixed/Failure)
* Not "degrees of success on a continuous scale requiring calculation"
* Example: Powered by the Apocalypse (6-, 7-9, 10+ are only outcomes)

**No Math During Play**

* Pre-calculate (weapon does "3 damage," not "roll d6, divide by 2, round up")
* Use tables (look up result, don't calculate)
* Example: GUMSHOE spends (simple cost, simple benefit)

**Design principle:** Math interrupts flow. Minimize calculation, maximize decision.

***

### Technique 5: Automation and Offloading

**Principle:** System handles what doesn't need player input.

**Why it helps:** Cognitive load spent on bookkeeping is load NOT spent on meaningful decisions.

***

**5A: Automated Bookkeeping**

**Computer/LLM Tracks State**

* Health, resources, conditions, timers (all automatic)
* Players just declare actions, system updates state
* Example: Digital RPGs auto-calculate damage, track inventory, manage quests

**Hidden Information Management**

* System maintains what players shouldn't know
* Example: LLM tracks NPC motivations, secret clues, world state (surfaces when relevant)

**Passive Systems**

* Things that happen automatically (don't require player decisions)
* Example: Resources generate over time, abilities recharge passively

**Design principle:** Automate the boring parts. Let players focus on interesting parts.

***

**5B: GM/System-Facing Complexity**

**Complex Behind the Scenes, Simple for Players**

* System can be complex if players don't see it
* Players experience simple interface, system does heavy lifting
* Example: LLM maintains elaborate world simulation, players just see coherent responses

**Asymmetric Load**

* GM/system handles load, players don't
* Example: GM tracks monster stats, players just describe actions

**Hidden Calculations**

* System determines outcomes based on invisible factors
* Players don't need to know the math, just the results
* Example: Stealth games (AI perception calculation hidden, players just see "spotted" or "hidden")

**Design principle:** Complexity can exist if it's invisible to players. What they don't see doesn't tax them.

***

**5C: Procedural Generation and Dynamic Content**

**LLM-Generated Content**

* System creates content on-demand (no preparation load)
* Example: NPC dialogue, descriptions, complications generated by LLM

**Adaptive Difficulty**

* System adjusts challenge based on player performance
* Players don't manage difficulty setting, system does
* Example: Left 4 Dead "AI Director" (spawns enemies based on player stress level)

**Dynamic Reminders**

* System surfaces relevant info when needed
* Example: "You have advantage because the enemy is prone" (system reminds, player doesn't track)

**Design principle:** Let system adapt and generate. Reduces prep load, increases responsiveness.

***

## Part C: Onboarding and Learning Curves

### Technique 6: Gradual Complexity Introduction

**Principle:** Don't overwhelm new players. Introduce complexity progressively.

**Why it matters:** High initial cognitive load causes drop-off. Players quit before seeing the depth.

***

**6A: Tutorial Design**

**Show, Don't Tell**

* First action teaches mechanics (not lengthy text explanation)
* Example: "Click here to move" → player moves → "Good! Now click enemy to attack"

**One Concept at a Time**

* Introduce mechanics sequentially (not all at once)
* Master one, then add next
* Example: Learn movement, then combat, then abilities, then resources

**Safe Practice Environment**

* Can't fail during tutorial (or failure teaches without punishing)
* Example: Tutorial missions impossible to lose, just teach mechanics

**Minimal Text**

* Lots of text = cognitive load (reading, remembering)
* Show visually, use minimal words
* Example: Highlight button that does X, let player press it

**Design principle:** Learn by doing. Keep text minimal, feedback immediate.

***

**6B: Graduated Complexity**

**Simple Start, Scale Up**

* Beginners start with subset of rules (not full complexity)
* Add more as they master basics
* Example: First chess lesson teaches pawn + king movement, not all pieces at once

**Unlock Mechanics Gradually**

* New abilities/systems introduced over time
* Not "here's 40 abilities, good luck"
* Example: Roguelikes unlock new items/enemies as you progress

**Optional Advanced Rules**

* Core game is simple, advanced rules are opt-in
* Experienced players can add complexity
* Example: Board games with basic + advanced modes

**Design principle:** Ramp difficulty. Start simple, get complex. Never dump all complexity at once.

***

**6C: Contextual Teaching**

**Just-in-Time Learning**

* Teach mechanics when they're relevant (not frontloaded)
* Example: Crafting tutorial appears when you first access crafting menu

**Tooltips and Help**

* Hover over thing → see what it does (no memorization needed)
* Always accessible (not just during tutorial)
* Example: Card game tooltips explain keywords on hover

**Embedded Reference**

* Help is part of UI (not separate manual)
* Example: Quick reference in pause menu, ability descriptions always visible

**Design principle:** Teach when needed, not when arbitrary. Help should be accessible, not memorized.

***

### Technique 7: Supporting Mastery Progression

**Principle:** As players improve, their cognitive load should change (not just stay same difficulty).

**Why it matters:** Mastery creates flow. Players should feel progression, not plateau.

***

**7A: Automation Through Practice**

**Build Muscle Memory**

* Repeated actions become automatic (don't need conscious thought)
* Frees up cognitive load for higher-level thinking
* Example: Fighting game combos (conscious execution → automatic → focus on spacing/mind-games)

**Pattern Recognition Development**

* Beginners calculate, experts see patterns instantly
* Load shifts from calculation to recognition
* Example: Chess (beginners count material, masters see positional themes)

**Hotkeys and Shortcuts**

* Efficient execution reduces mechanical load
* Frees brainspace for strategy
* Example: RTS hotkeys (faster building = more time for tactics)

**Design principle:** Practice should reduce execution load, reveal strategic depth.

***

**7B: Reveal Depth Gradually**

**Surface Simplicity, Hidden Depth**

* Easy to learn, hard to master
* Beginners succeed with basics, experts discover nuance
* Example: Go (simple rules, lifetime to master)

**Emergent Complexity**

* Simple systems interact in complex ways
* Discovery is part of mastery progression
* Example: Portal (simple mechanic—portals—but deep puzzle design)

**Meta-Game and Optimization**

* Once mechanics are mastered, optimization becomes focus
* Load shifts from "how do I play?" to "how do I play optimally?"
* Example: Roguelikes (first runs are learning, later runs are optimizing)

**Design principle:** Mastery should feel like DISCOVERING depth, not just executing faster.

***

**7C: Scalable Challenge**

**Difficulty Modes**

* Easy = low load (forgiving, simple)
* Hard = high load (punishing, complex)
* Players self-select appropriate level

**Ranked/Competitive Play**

* Matchmaking ensures opponents are similar skill
* Load scales with your improvement (always challenged, never overwhelmed)

**Self-Imposed Challenges**

* Expert players create their own constraints (speedruns, challenge runs, handicaps)
* Load scales infinitely (always room to optimize more)

**Design principle:** Challenge should match skill. Flow state requires appropriate difficulty.

***

## Part D: Case Studies in Load Management

### Case Study 1: Slay the Spire (Excellent Load Support)

**Load management techniques:**

**Externalization:**

* All card effects visible on cards (no memorization)
* Deck list accessible anytime (know what you have)
* Enemy intent shown (what they'll do next turn)

**Information Design:**

* Clear iconography (energy, block, damage, status effects)
* Color-coded card types (attacks red, skills green, powers purple)
* Tooltip on hover (full text of keywords)

**Simplified Resolution:**

* No complex calculation (card says "12 damage," that's what it does)
* No hidden modifiers (what you see is what you get)

**Graduated Complexity:**

* First run teaches basics (simple enemies, limited card pool)
* Higher ascensions add complexity (more mechanics, harder enemies)
* Can ignore complex strategies initially, discover them later

**Why it works:**

* Low load to start (can play casually)
* Deep optimization for experts (deck synergies, relic combos)
* Information always accessible (no memorization needed)

***

### Case Study 2: Darkest Dungeon (Load That Could Be Better Supported)

**Good load management:**

* Clear UI (health, stress, abilities visible)
* Turn-based (time to think)
* Tooltips (hover for info)

**Poor load management:**

* Hidden information (quirks, disease effects not fully explained)
* Opaque systems (how does stress exactly affect things?)
* Unintuitive mechanics (need wiki to understand optimal play)

**Player response:**

* Heavy wiki usage (looking up mechanics, optimal strategies)
* Frustration with hidden info ("how was I supposed to know that?")
* Trial-and-error learning (costly mistakes)

**How to improve:**

* More transparent systems (show exact mechanics in-game)
* Better tutorials (explain quirks, stress, afflictions clearly)
* In-game help (tooltips for all mechanics, not just abilities)

**Lesson:** Even good games can have poor load support. Players compensate with external tools (wikis), but in-game support would be better.

***

### Case Study 3: Factorio (Excellent Automation)

**Load management through automation:**

**Automate Everything:**

* Conveyor belts move items automatically (don't manually transport)
* Assemblers craft automatically (set recipe, walk away)
* Logistics network (items teleport where needed)

**Graduated Complexity:**

* Start manual (carry items, craft by hand)
* Automate simple chains (coal → power)
* Automate complex production (circuits, science packs)
* Automate entire factory (megabase, self-sustaining)

**Cognitive Load Shift:**

* Early: Learn recipes, build basic machines (high tutorial load)
* Mid: Design production chains (high design load)
* Late: Optimize throughput, debug bottlenecks (high systems thinking load)

**Why it works:**

* Automation removes execution load (don't manually do repetitive tasks)
* Allows focus on higher-level thinking (design, optimization)
* Load shifts from mechanical to strategic as you progress

**Lesson:** Automation isn't "making game easier"—it's removing boring load to focus on interesting load.

***

## Summary: Practical Load Management

**Key techniques:**

**Supporting Necessary Load:**

1. **Externalization** (reference sheets, journals, visual aids, digital tools)
2. **Information Design** (hierarchy, chunking, feedback, clarity)
3. **Scaffolded Decisions** (limit options, show consequences, structure complexity)

**Removing Unnecessary Load:**
4\. **Simplification** (elegant mechanics, abstract details, streamline resolution)
5\. **Automation** (bookkeeping handled by system, GM-facing complexity, procedural generation)

**Onboarding and Mastery:**
6\. **Gradual Complexity** (tutorials, unlocking systems, contextual teaching)
7\. **Mastery Progression** (automation through practice, reveal depth, scalable challenge)

**Design principles:**

* **Externalize memory** → Tools, not memorization
* **Visualize state** → See, don't calculate
* **Simplify ruthlessly** → Remove unnecessary complexity
* **Automate bookkeeping** → Focus on decisions, not tracking
* **Teach gradually** → One concept at a time
* **Support mastery** → Practice should automate execution, reveal strategy
* **Match load to skill** → Beginners need simplicity, experts need depth

**Common mistakes:**

* **No externalization** → Forces memorization of trackable info
* **Poor UI** → Information exists but hard to find/parse
* **Too complex too fast** → Overwhelms new players (high drop-off)
* **No automation** → Tedious bookkeeping competes with gameplay
* **Hidden information** → Players resort to wikis instead of in-game help
* **Flat difficulty** → No progression from beginner to expert

**Testing load support:**

* [ ] Can new players start playing within 15 minutes?
* [ ] Do players use external tools (wikis, spreadsheets) for info that should be in-game?
* [ ] Do players complain about "not knowing" information that exists but is hidden?
* [ ] Do players spend more time tracking than deciding?
* [ ] Does mastery feel rewarding (execution easier, strategy deeper)?
* [ ] Can players of different skill levels all enjoy the game?

**Golden rule:**

**Support load that serves the experience. Remove load that doesn't.**

If cognitive effort creates meaningful decisions, interesting discovery, or satisfying mastery → support it (tools, UI, scaffolding).

If cognitive effort is bookkeeping, unclear information, or arbitrary complexity → remove it (simplify, automate, abstract).

In the next chapter (Part 9), we'll integrate all these concepts into a step-by-step **design process framework** for creating games with appropriate cognitive load profiles.
