---
title: 14-summary
---
# Part 14: Summary and Principles

## Introduction

This book has explored cognitive load systematically: from foundations to case studies, from theory to practice. This final chapter distills everything into:

* **Core insights** (what we've learned)
* **Design principles** (actionable guidelines)
* **Quick reference guide** (at-a-glance reminders)
* **Decision-making checklists** (practical tools)
* **Key questions** (to ask yourself during design)

Use this chapter as your cognitive load design toolkit.

***

## Part A: Core Insights Recap

### Insight 1: Cognitive Load Is a Constraint, Not a Resource

**Resources** are in-game mechanical entities (HP, gold, spell slots).
**Cognitive load** is player mental capacity (external to game state).

**Why it matters:**

* Tools for resource design (scarcity, recovery) don't apply to cognitive load
* Must use different strategies (offloading, simplification, support)
* Cognitive load shapes what resource systems are feasible

**Key question:** "Is this resource worth the cognitive overhead it creates?"

***

### Insight 2: Cognitive Load Is a Design Tool, Not Just a Problem

**Different load levels create different experiences:**

* High load → Challenge, Mastery aesthetics
* Low load → Fellowship, Submission aesthetics
* Variable load → Discovery, Expression aesthetics

**Load isn't inherently good or bad—it must match intended experience.**

**Design decisions:**

* "How much thinking" is a design choice
* Match cognitive profile to aesthetic goal
* Support necessary load, remove unnecessary load

***

### Insight 3: Load Has Multiple Dimensions

**Seven types of cognitive load:**

1. **Simultaneity** (tracking multiple things at once)
2. **Decision** (evaluating options)
3. **Memory/Knowledge** (recalling information)
4. **Tracking** (monitoring game state)
5. **Calculation** (mathematical processing)
6. **Pattern Recognition** (learning through experience)
7. **Social/Communication** (interpersonal coordination)

**Each type serves different purposes and affects different aesthetics.**

**Design implication:** Analyze load by TYPE, not just total amount.

***

### Insight 4: Time Pressure Fundamentally Changes Cognitive Load

**Real-time vs. turn-based is NOT just pacing—it's a different cognitive game:**

* Real-time → limits complexity budget (must process under pressure)
* Turn-based → allows deeper systems (time to think)
* Same mechanics, different time = completely different experience

**Examples:**

* StarCraft (real-time) vs. Civilization (turn-based)
* They Are Billions with/without pause

**Design principle:** Time pressure is a cognitive load multiplier.

***

### Insight 5: Investment Changes Cognitive Load Over Time

**Multiple patterns exist:**

**A) Load Reduction (Dark Souls pattern):**

* Practice internalizes patterns → less cognitive load
* Front-loaded difficulty → progressive mastery
* Satisfaction from conquering load

**B) Load Revelation (StarCraft pattern):**

* Basics become automatic → notice deeper complexity
* Expert play reveals previously invisible optimizations
* "Always more to optimize"

**C) Load Independence (Cookie Clicker pattern):**

* Time passes, load stays low
* Investment is temporal, not cognitive

**Design consideration:** How should load change from beginner to expert?

***

### Insight 6: Load Can Be Distributed or Concentrated

**Multiplayer enables distributed cognition:**

* Total complexity can be higher (spread across players)
* Different roles → different load profiles (asymmetric)
* Coordination itself creates social cognitive load

**When distribution works:**

* Clear domains of responsibility
* Communication is possible and low-cost
* Coordination has value (mechanically rewarded)

**When distribution fails:**

* Quarterbacking (one player dominates)
* Unclear ownership (gaps in coverage)
* Communication overhead too high

**Design principle:** Distributed load enables higher total complexity, but requires intentional support.

***

### Insight 7: Load Mismatches Break Experiences

**Load must serve the intended experience:**

**Load in RIGHT place:**

* StarCraft simultaneity → challenge aesthetic
* Chess decision load → mastery aesthetic
* Among Us social load → fellowship aesthetic

**Load in WRONG place:**

* Death Stranding: Meditative traversal + complex systems (conflict)
* Kingdom Hearts: Action gameplay + convoluted lore (mismatch)
* EVE Online: Space combat fantasy + spreadsheet reality (wrong domain)

**Design principle:** Load should create desired aesthetic, not obstruct it.

***

### Insight 8: Player Types Have Different Load Preferences

**Bartle's taxonomy applied to cognitive load:**

**Achievers:** Want conquerable high load (mastery through optimization)
**Explorers:** Tolerate messy load (discovery through deep engagement)
**Socializers:** Prefer low mechanical load (brainspace for socializing)
**Killers:** Embrace competitive load (advantage through superior management)

**Design implication:** Know your target audience. Can't serve everyone equally.

***

### Insight 9: Load Support Is As Important As Load Design

**Supporting necessary load:**

* Externalization (journals, maps, reference cards)
* Information design (hierarchy, chunking, clarity)
* Scaffolded decisions (limit options, show consequences)

**Removing unnecessary load:**

* Simplification (elegant core mechanics, abstract details)
* Automation (bookkeeping handled by system)
* Offloading (GM/computer-facing complexity)

**Onboarding and mastery:**

* Gradual complexity introduction (one concept at a time)
* Just-in-time teaching (learn when relevant)
* Automation through practice (execution becomes effortless)

**Design principle:** Even high-load games need thoughtful support systems.

***

### Insight 10: LLMs Change What's Possible (But With Caveats)

**LLMs can handle:**

* State tracking and memory management (with context limits)
* Content generation (descriptions, dialogue, complications)
* Consistency maintenance (tone, themes, world logic)
* Adaptive difficulty (responding to player skill/preference)

**LLMs should NOT handle:**

* Precise calculation (bad at math)
* Rule adjudication (inconsistent interpretation)
* Long-term perfect memory (context windows are limited)
* Player-facing mechanical decisions (transparency matters)

**Design principle:** LLMs manage narrative/thematic load. Systems handle mechanical/mathematical load. Hybrid approaches work best.

***

## Part B: Design Principles Extracted

### Principle 1: Match Cognitive Load to Aesthetic Goal

**Challenge aesthetic:** High load is expected and welcome
**Fellowship aesthetic:** Low mechanical load frees brainspace for socializing
**Narrative aesthetic:** Minimal calculation preserves immersion
**Discovery aesthetic:** Load in synthesis, not tracking
**Mastery aesthetic:** Conquerable high load creates satisfaction

**Action:** Before designing mechanics, identify primary aesthetic. Design load profile to serve it.

***

### Principle 2: Time Pressure Reduces Complexity Budget

**Real-time systems:**

* Must be parseable under pressure
* Limit simultaneous demands
* Clear visual feedback essential
* Intuitive > optimal

**Turn-based systems:**

* Can afford deeper complexity
* Players have time to calculate
* Can support more resources, options
* Analysis > reflex

**Action:** Choose time structure FIRST. It constrains everything else.

***

### Principle 3: Offload Complexity Strategically

**Player-facing:** Only what creates meaningful decisions
**GM-facing:** Human referee absorbs complexity (hidden mechanics)
**Computer-facing:** Automation handles tracking and calculation
**LLM-facing:** Narrative coherence, adaptive content generation

**Action:** For each game element, ask: "Does the player need to see this, or can it be hidden?"

***

### Principle 4: Simplification ≠ Dumbing Down

**Elegant design:**

* Fewer rules, more depth (emergent complexity)
* Consistent resolution systems (one mechanic, many applications)
* Abstract unnecessary details (Light/Medium/Heavy instead of exact counts)

**Complexity for depth, not busywork:**

* Simple rules + complex interactions (Chess, Go)
* NOT complex rules + shallow interactions (many bad RPGs)

**Action:** Audit every mechanic. Does it create meaningful decisions, or just friction?

***

### Principle 5: Spatial > Numerical Complexity

**Visual/spatial reasoning is easier than abstract calculation:**

* Map boards vs. text descriptions
* Position tokens vs. remembered locations
* Color coding vs. memorizing categories

**Action:** When possible, externalize state visually. Show, don't tell.

***

### Principle 6: UI Affects Cognitive Load As Much As Mechanics

**Good UI reduces load:**

* Information hierarchy (important things prominent)
* Consistent layout (spatial memory)
* Clear feedback (immediate confirmation)
* Progressive disclosure (show what's needed, hide what's not)

**Bad UI increases load:**

* Hunt for information (poor organization)
* Ambiguous state (is my ability ready?)
* Hidden complexity (no tooltips, no reference)

**Action:** UI isn't cosmetic. It's a cognitive load management system.

***

### Principle 7: Design for Learning Curve (Novice → Expert)

**Onboarding:**

* Simple start (subset of rules)
* One concept at a time
* Learn by doing, not reading

**Progression:**

* Unlock complexity gradually
* Just-in-time teaching (when relevant)
* Patterns become automatic

**Mastery:**

* Depth reveals itself
* Optimization becomes focus
* Challenge scales with skill

**Action:** Map expected learning journey. Design for ALL stages, not just expert play.

***

### Principle 8: "Skill Through Impossibility" Requires Elegance

**Can work when:**

* Constraint is choosing WHAT to do (StarCraft simultaneity)
* Simple actions, impossible totality (Go, Chess)
* Prioritization is skill expression

**Doesn't work when:**

* Constraint is just too much STUFF (Dwarf Fortress tracking)
* Arbitrary complexity (memorizing trivia)
* No clear pattern to learn

**Action:** If humanly impossible is design goal, ensure it's about decision prioritization, not just overwhelm.

***

### Principle 9: Scalable Complexity Serves Multiple Audiences

**Surface simplicity:**

* Can play without mastery (accessible)
* Social players can ignore optimization

**Hidden depth:**

* Discoverable for those who seek it
* Achievers can optimize endlessly

**Implementation:**

* Layered difficulty (easy/normal/hard modes)
* Role differentiation (simple and complex roles)
* Optional mechanics (advanced rules are opt-in)

**Action:** Design for your PRIMARY audience, but accommodate secondary audiences when possible.

***

### Principle 10: Cognitive Load Is a Constraint to Respect

**You cannot:**

* "Spend" cognitive load like a resource
* Recover it within game mechanics
* Ignore human working memory limits (\~7 items)

**You must:**

* Accommodate player mental capacity
* Support load with tools (externalization, UI, automation)
* Match load to target audience (casual vs. hardcore)

**Action:** Always ask: "Can players actually MANAGE this cognitive demand?"

***

## Part C: Quick Reference Guide

### Load Type Definitions

| Load Type                | Definition                       | Example                  |
| ------------------------ | -------------------------------- | ------------------------ |
| **Simultaneity**         | Tracking multiple things at once | StarCraft macro + micro  |
| **Decision**             | Evaluating options               | Chess move selection     |
| **Memory/Knowledge**     | Recalling information            | Warhammer rules          |
| **Tracking**             | Monitoring game state            | Dwarf Fortress citizens  |
| **Calculation**          | Mathematical processing          | Damage formulas          |
| **Pattern Recognition**  | Learning through experience      | Dark Souls boss patterns |
| **Social/Communication** | Interpersonal coordination       | Among Us discussion      |

***

### Aesthetic-Load Pairings

| Aesthetic (MDA) | Preferred Load Level      | Load Types That Serve               |
| --------------- | ------------------------- | ----------------------------------- |
| **Challenge**   | HIGH (if conquerable)     | Decision, Pattern, Calculation      |
| **Fellowship**  | LOW (mechanical)          | Social (high), Mechanical (low)     |
| **Narrative**   | LOW (mechanical)          | Memory (for story), not Calculation |
| **Discovery**   | Variable (tolerates mess) | Tracking, Memory, Pattern           |
| **Mastery**     | HIGH (if learnable)       | All types, but must be conquerable  |
| **Submission**  | LOW (relaxation)          | Minimal cognitive engagement        |
| **Expression**  | Variable                  | Depends on expression type          |
| **Sensation**   | LOW (don't overthink)     | Minimal, focus on sensory input     |

***

### Player Type Preferences

| Player Type (Bartle) | Load Preference              | Seeks                           | Avoids                          |
| -------------------- | ---------------------------- | ------------------------------- | ------------------------------- |
| **Achievers**        | HIGH (conquerable)           | Decision, Pattern, Optimization | Random, Trivial, Arbitrary      |
| **Explorers**        | Variable (tolerates mess)    | Discovery, System Depth         | Gated Content, Time Pressure    |
| **Socializers**      | LOW (mechanical)             | Social/Communication            | Complex Mechanics, Silent Focus |
| **Killers**          | HIGH (competitive advantage) | Decision, Psychological         | Pure Cooperation, Luck-Based    |

***

### Load Management Strategies

| Problem                      | Strategy               | Examples                                  |
| ---------------------------- | ---------------------- | ----------------------------------------- |
| **Too much tracking**        | Externalization        | Tokens, dials, character sheets, maps     |
| **Too many options**         | Limit/structure        | 3-5 clear choices, not infinite           |
| **Complex calculation**      | Simplify/automate      | 2d6 vs. 3d8+2d6-1d4+5                     |
| **Unclear consequences**     | Transparency           | Show expected outcomes, %s                |
| **Information overload**     | Hierarchy/chunking     | Important info prominent, related grouped |
| **Memory burden**            | Reference materials    | Quick-reference cards, tooltips, help     |
| **Real-time pressure**       | Turn-based OR simplify | Limit simultaneous demands                |
| **Learning curve too steep** | Gradual complexity     | Unlock systems over time, tutorials       |

***

## Part D: Decision-Making Checklists

### Checklist 1: Initial Design

**Use when:** Starting a new game or system.

**Core Experience:**

* [ ] What should players FEEL?
* [ ] What should players UNDERSTAND?
* [ ] What should players DO?
* [ ] What's the primary aesthetic (Challenge, Fellowship, Narrative, Discovery, etc.)?

**Load Requirements:**

* [ ] What cognitive load types does this aesthetic require?
* [ ] Should load be HIGH, LOW, or VARIABLE in each dimension?
* [ ] Are there conflicts between load requirements?
* [ ] How will load change from beginner to expert?

**Target Audience:**

* [ ] What player types am I designing for (Achievers, Explorers, Socializers, Killers)?
* [ ] What load tolerance do they have?
* [ ] Can I accommodate multiple types?

**Constraints:**

* [ ] Session length, frequency (affects memory load)
* [ ] Real-time or turn-based (affects simultaneity/decision load)
* [ ] Platform/tools available (affects what can be automated)
* [ ] Player group size (affects load distribution options)

***

### Checklist 2: System Design

**Use when:** Designing specific mechanics or systems.

**For Each Mechanic/System:**

**Load Analysis:**

* [ ] What cognitive load does this create (type and amount)?
* [ ] Does this load serve the experience, or obstruct it?
* [ ] Is this load necessary, or can it be removed/simplified?

**Appropriateness:**

* [ ] Does load match intended aesthetic?
* [ ] Can target audience handle this load?
* [ ] Is load in the right place (not wrong domain)?

**Support:**

* [ ] Can players externalize this load (reference materials, tools)?
* [ ] Can this be automated (computer/LLM handles it)?
* [ ] Is information clearly presented (UI, feedback)?
* [ ] Can players learn this through play (onboarding)?

**Integration:**

* [ ] How does this interact with other systems (compounding load)?
* [ ] Does this maintain coherence (mechanics + context aligned)?
* [ ] Can players manage total load (not overwhelming when combined)?

***

### Checklist 3: LLM Integration

**Use when:** Deciding what LLM should/shouldn't handle.

**For Each Proposed LLM Use:**

**Capability Check:**

* [ ] Does this require precision (math, rules adjudication)? → Don't use LLM
* [ ] Does this require creativity/adaptation (content generation)? → LLM can help
* [ ] Does this require consistency (tracking state, NPC memory)? → LLM with explicit constraints
* [ ] Does this need transparency (player-facing decisions)? → Explicit system, not LLM

**Load Impact:**

* [ ] Will LLM reduce cognitive load (offloading tracking, just-in-time info)?
* [ ] Or increase it (choice paralysis, ambiguity, trust issues)?
* [ ] Can LLM failures be handled gracefully (player won't notice/care)?

**Integration:**

* [ ] Is this LLM-primary (core function) or LLM-support (helper)?
* [ ] What explicit rules/constraints must LLM follow?
* [ ] How do LLM and system interact (hybrid approach)?
* [ ] Can we validate LLM output (ensure consistency)?

***

### Checklist 4: Load Support

**Use when:** Adding tools, UI, or support systems.

**Externalization:**

* [ ] What information needs to be tracked? (make visible, not memorized)
* [ ] Can we provide reference materials? (quick-ref sheets, cards)
* [ ] Can we use visual/spatial aids? (maps, tokens, color-coding)
* [ ] Can we provide digital tools? (character sheets, calculators)

**Information Design:**

* [ ] Is important information prominent? (size, color, position)
* [ ] Is related information grouped? (chunked, not scattered)
* [ ] Is feedback immediate and clear? (what just happened?)
* [ ] Can players find information quickly? (search, tooltips)

**Simplification:**

* [ ] Can we use simpler resolution? (2d6 vs. complex formula)
* [ ] Can we abstract details? (Light/Medium/Heavy vs. exact counts)
* [ ] Can we unify systems? (one mechanic for everything)
* [ ] Can we remove exceptions? (consistent rules)

**Automation:**

* [ ] What can computer/LLM handle invisibly? (bookkeeping)
* [ ] What should remain player-facing? (decisions)
* [ ] Can we automate passive systems? (resources regenerate)
* [ ] Can we provide reminders/prompts? (surfacing relevant info)

**Onboarding:**

* [ ] Can players start playing quickly? (15-30 min to first action)
* [ ] Is complexity introduced gradually? (one concept at a time)
* [ ] Do players learn by doing? (not just reading)
* [ ] Is help accessible during play? (tooltips, pause-menu reference)

***

### Checklist 5: Playtesting

**Use when:** Testing with actual players.

**Before Playing:**

* [ ] What load aspects are we testing? (specific focus)
* [ ] What player types are in this test? (Achievers, Socializers, etc.)
* [ ] What skill levels? (novice, experienced, expert)

**During Play - Observe:**

* [ ] Do players use workarounds? (wikis, spreadsheets, notes)
* [ ] Do players show analysis paralysis? (long turns, indecision)
* [ ] Do players go on autopilot? (disengagement, boredom)
* [ ] Do players complain about "wrong" things? (mechanics, not challenge)
* [ ] Do players coordinate effectively? (if multiplayer)
* [ ] Do players quit early? (overwhelm, frustration)

**After Play - Ask:**

* [ ] How mentally demanding was this? (subjective load)
* [ ] What was hardest to keep track of? (identify load sources)
* [ ] What was confusing or unclear? (information design issues)
* [ ] What felt tedious vs. interesting? (necessary vs. unnecessary load)
* [ ] Would you play again? Why/why not? (engagement, satisfaction)

**Analysis:**

* [ ] Does observed load match intended load profile?
* [ ] Are there load mismatches (wrong place, wrong type)?
* [ ] What needs support (tools, UI, simplification)?
* [ ] What needs removal (unnecessary complexity)?

***

## Part E: Key Questions for Designers

### Questions to Ask Yourself During Design

**Phase 1: Concept**

1. What experience am I trying to create? (feel, understand, do)
2. What aesthetic(s) am I targeting? (Challenge, Fellowship, Narrative, etc.)
3. Who is this for? (Achievers, Explorers, Socializers, Killers)
4. What's the context? (session length, frequency, platform, group size)

**Phase 2: Load Profile**
5\. What cognitive load types does this experience require?
6\. Should each load type be HIGH, LOW, or VARIABLE?
7\. Are there conflicts between load requirements? How do I resolve them?
8\. How should load change from beginner to expert?

**Phase 3: Mechanics**
9\. What verbs/actions do players need?
10\. How many mechanics are necessary? (can I simplify?)
11\. Does each mechanic justify its cognitive cost?
12\. Are mechanics unified (one system) or varied (multiple systems)?

**Phase 4: Parameters**
13\. How many resources/stats can players realistically track?
14\. Are numbers simple (0-10) or complex (1-9999)?
15\. Are there derived stats? Can they be pre-calculated?

**Phase 5: Context**
16\. Does fiction reduce load (intuitive) or add load (arbitrary)?
17\. Do rules and fiction align (coherent) or conflict (dissonance)?
18\. Is theming helping memory, or just cosmetic?

**Phase 6: Pacing**
19\. Real-time or turn-based? (fundamental load constraint)
20\. Are there rest/downtime periods? (cognitive recovery)
21\. Does pacing match aesthetic? (Fellowship = relaxed, Challenge = intense)

**Phase 7: Support**
22\. What information can be externalized? (reference materials, tools)
23\. What can be automated? (computer/LLM handles)
24\. Is UI clear and organized? (information hierarchy)
25\. How do players learn? (onboarding, tutorials, just-in-time teaching)

**Phase 8: LLM Integration** (if applicable)
26\. What should LLM handle? (narrative, state tracking, generation)
27\. What should remain explicit? (rules, calculations, balance)
28\. What are the risks? (inconsistency, choice paralysis, trust)

**Phase 9: Validation**
29\. Does load profile match intended experience?
30\. Are there load mismatches? (wrong place, wrong type, wrong amount)
31\. Can target audience handle this? (not too overwhelming, not too boring)
32\. Does the system achieve experiential goals? (feel, understand, do)

**Phase 10: Iteration**
33\. What did playtesting reveal? (observe behavior, gather feedback)
34\. What needs simplification? (unnecessary load to remove)
35\. What needs support? (necessary load that's hard to manage)
36\. What's working well? (don't break what's succeeding)

***

## Part F: Putting It All Together

### The Cognitive Load Design Process (Summary)

**Step 1: Define Experience**

* What should players feel, understand, and do?
* What aesthetic(s) are you targeting?
* Who is your audience?

**Step 2: Determine Load Requirements**

* What load types does this experience require?
* High, low, or variable in each dimension?
* Resolve conflicts between requirements

**Step 3: Design Systems**

* Create mechanics that generate appropriate load
* Remove load that doesn't serve experience
* Support necessary load with tools

**Step 4: Integrate LLM (if applicable)**

* LLM for narrative, adaptation, state tracking
* Explicit systems for rules, math, balance
* Hybrid approaches when both needed

**Step 5: Validate Through Play**

* Observe player behavior
* Measure load (subjective + objective)
* Check for mismatches (wrong place, wrong amount)

**Step 6: Iterate**

* Simplify what's unnecessary
* Support what's necessary
* Refine until load matches experience

***

### The Golden Rule

**Support cognitive load that serves the experience.**

**Remove cognitive load that doesn't.**

If mental effort creates meaningful decisions, interesting discovery, or satisfying mastery → support it with tools, UI, and scaffolding.

If mental effort is just bookkeeping, unclear information, or arbitrary complexity → remove it through simplification, automation, or abstraction.

**Cognitive load isn't inherently good or bad. It's a tool. Wield it intentionally.**

***

## Final Thoughts: Designing With Cognitive Load in Mind

This book has provided:

* **Theory:** Understanding what cognitive load is and how it works
* **Analysis:** Case studies showing load in action across different games
* **Process:** Step-by-step framework for designing with load intentionally
* **Tools:** Checklists, principles, and questions to guide decisions

**But theory and tools are just starting points.**

**True mastery comes from:**

* **Practice:** Designing, testing, iterating
* **Observation:** Watching real players engage with your systems
* **Reflection:** Understanding why things worked or didn't
* **Experimentation:** Trying new approaches, learning from failure

**Cognitive load is not a problem to solve once and forget.**

It's a dimension of every design choice you make:

* Every resource you add
* Every mechanic you introduce
* Every parameter you tune
* Every UI element you design
* Every tutorial step you write

**The question is always: "What are you asking players to think about?"**

And then: **"Is that what you WANT them thinking about?"**

If yes → support it.
If no → remove it.
If unsure → test it.

**Games are experiential scaffolds.** They exist to enable experiences—feelings, understandings, actions—that wouldn't be possible otherwise.

**Cognitive load is part of that scaffold.** Used well, it creates challenge, discovery, mastery, connection. Used poorly, it creates frustration, confusion, disengagement.

**Your job as a designer is to wield cognitive load intentionally:**

* Know what load you're creating
* Understand why (or why not) it serves your experience
* Provide support where needed
* Simplify ruthlessly where possible
* Test with real players
* Iterate based on what you learn

**This is not a checklist to complete.** It's a lens to design through.

Every time you make a design choice, ask: *"What does this do to cognitive load? Is that what I want?"*

Over time, this becomes intuition. You'll feel when load is right or wrong. You'll see mismatches before they happen. You'll design systems that elegantly match their intended experience.

**But it starts with awareness.** With asking the questions. With testing and learning.

**So go design something.** Apply what you've learned. Test it. See what happens. Iterate.

And when you discover something new—something this book didn't cover—share it. Teach it. Add to the collective knowledge.

**The field of cognitive load in game design is young.** There's so much we still don't know. So many questions still open. So many possibilities unexplored.

**You're not just using this framework—you're helping build it.**

Every game you design, every test you run, every player you observe adds to our understanding.

**So go forth and design with intention.**

Ask: "What experience do I want to create?"

Then: "What cognitive load profile serves that experience?"

Then: "How do I design systems to match?"

And finally: "How do I support players in managing that load?"

**The rest is iteration.**

Good luck, and happy designing.

***

## Appendix: One-Page Summary

### Cognitive Load in Game Design - Quick Guide

**What It Is:**

* Mental effort required to play (tracking, decisions, memory, calculation)
* EXTERNAL constraint (not in-game resource)
* Multi-dimensional (simultaneity, decision, memory, tracking, calculation, pattern, social)

**Why It Matters:**

* Different loads create different experiences
* Load must match intended aesthetic (Challenge ≠ Fellowship ≠ Narrative)
* Players have limited capacity (\~7 items in working memory)

**Core Principles:**

1. Match load to aesthetic goal
2. Time pressure reduces complexity budget
3. Offload strategically (player/GM/computer/LLM)
4. Simplification ≠ dumbing down (fewer rules, more depth)
5. Spatial > numerical (show, don't calculate)
6. UI is load management (not just cosmetic)
7. Design for learning curve (novice → expert)
8. "Skill through impossibility" requires elegance
9. Scalable complexity serves multiple audiences
10. Respect cognitive constraints (can't be "spent" like resource)

**Design Process:**

1. Define experience (feel, understand, do)
2. Determine load requirements (high/low for each type)
3. Design systems (mechanics that create appropriate load)
4. Support necessary load (tools, UI, automation)
5. Remove unnecessary load (simplify, automate)
6. Validate (test with real players)
7. Iterate (refine based on observations)

**Key Questions:**

* What experience am I creating?
* What cognitive load does this require?
* Does this load serve the experience?
* Can players manage this load?
* How can I support or remove load?

**Remember:** Load isn't good or bad. It's a tool. Use it intentionally to create the experience you want.
